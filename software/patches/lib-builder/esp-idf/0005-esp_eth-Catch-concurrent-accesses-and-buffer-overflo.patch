From b803c05838f8e2a087bfe3d70272d3bfcddfba23 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Mattias=20Sch=C3=A4ffersmann?= <mattias@tinkerforge.com>
Date: Thu, 21 Sep 2023 13:36:23 +0200
Subject: [PATCH] esp_eth: Catch concurrent accesses and buffer overflows.

- Introduce a semaphore to catch concurrent accesses to esp_eth_transmit.
- Use CPU watchpoints to catch buffer overflows in ethernet TX buffers.
---
 components/esp_eth/src/esp_eth.c         | 8 ++++++++
 components/esp_eth/src/esp_eth_mac_esp.c | 8 ++++++++
 2 files changed, 16 insertions(+)

diff --git a/components/esp_eth/src/esp_eth.c b/components/esp_eth/src/esp_eth.c
index f6e7526cc0..0ad026d1f1 100644
--- a/components/esp_eth/src/esp_eth.c
+++ b/components/esp_eth/src/esp_eth.c
@@ -47,6 +47,7 @@ typedef struct {
     atomic_int ref_count;
     void *priv;
     _Atomic esp_eth_fsm_t fsm;
+    SemaphoreHandle_t transmit_mutex;
     esp_err_t (*stack_input)(esp_eth_handle_t eth_handle, uint8_t *buffer, uint32_t length, void *priv);
     esp_err_t (*on_lowlevel_init_done)(esp_eth_handle_t eth_handle);
     esp_err_t (*on_lowlevel_deinit_done)(esp_eth_handle_t eth_handle);
@@ -187,6 +188,8 @@ esp_err_t esp_eth_driver_install(const esp_eth_config_t *config, esp_eth_handle_
         .skip_unhandled_events = true
     };
     ESP_GOTO_ON_ERROR(esp_timer_create(&check_link_timer_args, &eth_driver->check_link_timer), err, TAG, "create link timer failed");
+    eth_driver->transmit_mutex = xSemaphoreCreateMutex();
+    ESP_GOTO_ON_FALSE(eth_driver->transmit_mutex, ESP_ERR_NO_MEM, err, TAG, "Failed to create transmit mutex");
     atomic_init(&eth_driver->ref_count, 1);
     atomic_init(&eth_driver->fsm, ESP_ETH_FSM_STOP);
     eth_driver->mac = mac;
@@ -331,7 +334,12 @@ esp_err_t esp_eth_transmit(esp_eth_handle_t hdl, void *buf, size_t length)
     ESP_GOTO_ON_FALSE(length, ESP_ERR_INVALID_ARG, err, TAG, "buf length can't be zero");
     ESP_GOTO_ON_FALSE(eth_driver, ESP_ERR_INVALID_ARG, err, TAG, "ethernet driver handle can't be null");
     esp_eth_mac_t *mac = eth_driver->mac;
+
+    if (xSemaphoreTake(eth_driver->transmit_mutex, 0) == pdFALSE) {
+        esp_system_abort("Concurrent access to esp_eth_transmit detected!");
+    }
     ret = mac->transmit(mac, buf, length);
+    xSemaphoreGive(eth_driver->transmit_mutex);
 err:
     return ret;
 }
diff --git a/components/esp_eth/src/esp_eth_mac_esp.c b/components/esp_eth/src/esp_eth_mac_esp.c
index 03248ff8a8..c9eb8e6d43 100644
--- a/components/esp_eth/src/esp_eth_mac_esp.c
+++ b/components/esp_eth/src/esp_eth_mac_esp.c
@@ -477,11 +477,19 @@ static esp_err_t esp_emac_alloc_driver_obj(const eth_mac_config_t *config, emac_
     for (int i = 0; i < CONFIG_ETH_DMA_RX_BUFFER_NUM; i++) {
         emac->rx_buf[i] = heap_caps_calloc(1, CONFIG_ETH_DMA_BUFFER_SIZE, MALLOC_CAP_DMA);
         ESP_GOTO_ON_FALSE(emac->rx_buf[i], ESP_ERR_NO_MEM, err, TAG, "no mem for RX DMA buffers");
+        ESP_LOGE(TAG, "RX buffer %i: %iB @ %p", i, CONFIG_ETH_DMA_BUFFER_SIZE, emac->rx_buf[i]);
     }
     for (int i = 0; i < CONFIG_ETH_DMA_TX_BUFFER_NUM; i++) {
         emac->tx_buf[i] = heap_caps_calloc(1, CONFIG_ETH_DMA_BUFFER_SIZE, MALLOC_CAP_DMA);
         ESP_GOTO_ON_FALSE(emac->tx_buf[i], ESP_ERR_NO_MEM, err, TAG, "no mem for TX DMA buffers");
+        ESP_LOGE(TAG, "TX buffer %i: %iB @ %p", i, CONFIG_ETH_DMA_BUFFER_SIZE, emac->tx_buf[i]);
     }
+    // ==============================
+
+    esp_cpu_set_watchpoint(0, emac->tx_buf[1] + CONFIG_ETH_DMA_BUFFER_SIZE, 4, ESP_WATCHPOINT_STORE);
+    esp_cpu_set_watchpoint(1, emac->tx_buf[2] + CONFIG_ETH_DMA_BUFFER_SIZE, 4, ESP_WATCHPOINT_STORE);
+
+    // ==============================
     /* alloc PM lock */
 #ifdef CONFIG_PM_ENABLE
     ESP_GOTO_ON_ERROR(esp_pm_lock_create(ESP_PM_APB_FREQ_MAX, 0, "emac_esp32", &emac->pm_lock), err, TAG, "create pm lock failed");
-- 
2.30.2

