From 3524d7925b78c8438ca4ec33c1fbfa897ec1285b Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Mattias=20Sch=C3=A4ffersmann?= <mattias@tinkerforge.com>
Date: Wed, 13 Sep 2023 11:32:13 +0200
Subject: [PATCH] Fix heap_caps_check_integrity* functions to find buffer
 overflows.

The heap code already contains code to verify in-use memory blocks but it is
never called on in-use blocks. This patch makes heap_caps_check_integrity*
functions also verify all in-use blocks.
---
 components/heap/heap_tlsf.c            | 12 ++++++++----
 components/heap/multi_heap_poisoning.c |  3 +--
 2 files changed, 9 insertions(+), 6 deletions(-)

diff --git a/components/heap/heap_tlsf.c b/components/heap/heap_tlsf.c
index 334b88eb5f..b20ccfd541 100644
--- a/components/heap/heap_tlsf.c
+++ b/components/heap/heap_tlsf.c
@@ -533,6 +533,10 @@ typedef struct integrity_t
 
 #define tlsf_insist(x) { if (!(x)) { status--; } }
 
+#ifdef MULTI_HEAP_POISONING
+extern bool tlsf_check_hook(void *start, size_t size, bool is_free);
+#endif
+
 static void integrity_walker(void* ptr, size_t size, int used, void* user)
 {
 	block_header_t* block = block_from_ptr(ptr);
@@ -546,14 +550,14 @@ static void integrity_walker(void* ptr, size_t size, int used, void* user)
 	tlsf_insist(integ->prev_status == this_prev_status && "prev status incorrect");
 	tlsf_insist(size == this_block_size && "block size incorrect");
 
+#ifdef MULTI_HEAP_POISONING
+	tlsf_insist(tlsf_check_hook((void*)block + sizeof(block_header_t), size, this_status));
+#endif
+
 	integ->prev_status = this_status;
 	integ->status += status;
 }
 
-#ifdef MULTI_HEAP_POISONING
-extern bool tlsf_check_hook(void *start, size_t size, bool is_free);
-#endif
-
 int tlsf_check(tlsf_t tlsf)
 {
 	int i, j;
diff --git a/components/heap/multi_heap_poisoning.c b/components/heap/multi_heap_poisoning.c
index 9f0ca9dd8d..5cdcda7ada 100644
--- a/components/heap/multi_heap_poisoning.c
+++ b/components/heap/multi_heap_poisoning.c
@@ -404,8 +404,7 @@ bool multi_heap_internal_check_block_poisoning(void *start, size_t size, bool is
         return true; /* can only verify empty blocks in SLOW mode */
 #endif
     } else {
-        void *data = (void *)((intptr_t)start + sizeof(poison_head_t));
-        poison_head_t *head = verify_allocated_region(data, print_errors);
+        poison_head_t *head = verify_allocated_region(start, print_errors);
         if (head != NULL && head->alloc_size > size - POISON_OVERHEAD) {
             /* block can be bigger than alloc_size, for reasons of alignment & fragmentation,
                but block can never be smaller than head->alloc_size... */
-- 
2.30.2

