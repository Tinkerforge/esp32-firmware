
// This file is generated by pre_generator.py
#include "module.h"
#include "config.h"
#include <string>
#include <vector>
#include <map>
#include <optional>

namespace ArduinoJson {
template <typename T>
struct Converter<std::vector<T> > {
  static void toJson(const std::vector<T>& src, JsonVariant dst) {
    JsonArray array = dst.to<JsonArray>();
    for (T item : src)
      array.add(item);
  }

  static std::vector<T> fromJson(JsonVariantConst src) {
    std::vector<T> dst;
    for (T item : src.as<JsonArrayConst>())
      dst.push_back(item);
    return dst;
  }

  static bool checkJson(JsonVariantConst src) {
    JsonArrayConst array = src;
    bool result = array;
    for (JsonVariantConst item : array)
      result &= item.is<T>();
    return result;
  }
};
}  // namespace ArduinoJson

using MessagingNumberType = int;
using MessagingDataTextType = std::string;
using LabelType = std::string;
using DescriptionType = std::string;
using SpecificationVersionType = std::string;
using EnumExtendType = std::string;
using DayOfMonthType = int;
using CalendarWeekType = int;
using NumberType = int;
using ScaleType = int;
using MaxResponseDelayType = uint64_t;
using AddressDeviceType = std::string;
using AddressEntityType = int;
using AddressFeatureType = int;
using FeatureGroupType = std::string;
using TimeSeriesIdType = int;
using TimeSeriesSlotIdType = int;
using TimeSeriesSlotCountType = std::string;
using MeasurementIdType = int;
using ThresholdIdType = int;
using AlternativesIdType = int;
using PowerSequenceIdType = int;
using PowerTimeSlotNumberType = int;
using ErrorNumberType = int;
using BindingIdType = int;
using MsgCounterType = int;
using FilterIdType = int;
using AlarmIdType = int;
using BillIdType = int;
using BillPositionIdType = int;
using BillPositionCountType = std::string;
using BillValueIdType = int;
using BillCostIdType = int;
using IdentificationIdType = int;
using IdentificationValueType = std::string;
using SessionIdType = int;
using PurposeIdType = std::string;
using ChannelIdType = int;
using DeviceClassificationStringType = std::string;
using DeviceConfigurationKeyIdType = int;
using DeviceConfigurationKeyValueStringType = std::string;
using VendorStateCodeType = std::string;
using LastErrorCodeType = std::string;
using ElectricalConnectionIdType = int;
using ElectricalConnectionParameterIdType = int;
using ElectricalConnectionCharacteristicIdType = int;
using HvacSystemFunctionIdType = int;
using HvacOperationModeIdType = int;
using HvacOverrunIdType = int;
using SetpointIdType = int;
using TimeTableIdType = int;
using TimeSlotIdType = int;
using TimeSlotCountType = std::string;
using TariffIdType = int;
using TariffCountType = std::string;
using TierBoundaryIdType = int;
using TierBoundaryCountType = std::string;
using CommodityIdType = int;
using TierIdType = int;
using TierCountType = std::string;
using IncentiveIdType = int;
using IncentiveCountType = std::string;
using IncentivePriorityType = int;
using LoadControlEventIdType = int;
using LoadControlLimitIdType = int;
using NetworkManagementNativeSetupType = std::string;
using NetworkManagementScanSetupType = std::string;
using NetworkManagementSetupType = std::string;
using NetworkManagementCandidateSetupType = std::string;
using NetworkManagementTechnologyAddressType = std::string;
using NetworkManagementCommunicationsTechnologyInformationType = std::string;
using NetworkManagementMinimumTrustLevelType = std::string;
using NetworkManagementProcessTimeoutType = uint64_t;
using SubscriptionIdType = int;
using UseCaseActorEnumType = std::string;
using UseCaseNameEnumType = std::string;
using UseCaseScenarioSupportType = int;
using stateInformationIdType = int;
using ConditionIdType = int;
using TaskManagementJobIdType = int;
enum class MessagingTypeEnumType {
	logging,
	information,
	warning,
	alarm,
	emergency,
	obsolete,
};
bool convertToJson(const MessagingTypeEnumType &src, JsonVariant& dst);
void convertFromJson(const JsonVariantConst& src, MessagingTypeEnumType &dst);

enum class RecurringIntervalEnumType {
	yearly,
	monthly,
	weekly,
	daily,
	hourly,
	everyMinute,
	everySecond,
};
bool convertToJson(const RecurringIntervalEnumType &src, JsonVariant& dst);
void convertFromJson(const JsonVariantConst& src, RecurringIntervalEnumType &dst);

enum class MonthType {
	january,
	february,
	march,
	april,
	may,
	june,
	july,
	august,
	september,
	october,
	november,
	december,
};
bool convertToJson(const MonthType &src, JsonVariant& dst);
void convertFromJson(const JsonVariantConst& src, MonthType &dst);

enum class DayOfWeekType {
	monday,
	tuesday,
	wednesday,
	thursday,
	friday,
	saturday,
	sunday,
};
bool convertToJson(const DayOfWeekType &src, JsonVariant& dst);
void convertFromJson(const JsonVariantConst& src, DayOfWeekType &dst);

enum class OccurrenceEnumType {
	first,
	second,
	third,
	fourth,
	last,
};
bool convertToJson(const OccurrenceEnumType &src, JsonVariant& dst);
void convertFromJson(const JsonVariantConst& src, OccurrenceEnumType &dst);

enum class CommodityTypeEnumType {
	electricity,
	gas,
	oil,
	water,
	wasteWater,
	domesticHotWater,
	heatingWater,
	steam,
	heat,
	coolingLoad,
	air,
};
bool convertToJson(const CommodityTypeEnumType &src, JsonVariant& dst);
void convertFromJson(const JsonVariantConst& src, CommodityTypeEnumType &dst);

enum class EnergyDirectionEnumType {
	consume,
	produce,
};
bool convertToJson(const EnergyDirectionEnumType &src, JsonVariant& dst);
void convertFromJson(const JsonVariantConst& src, EnergyDirectionEnumType &dst);

enum class EnergyModeEnumType {
	consume,
	produce,
	idle,
	auto,
};
bool convertToJson(const EnergyModeEnumType &src, JsonVariant& dst);
void convertFromJson(const JsonVariantConst& src, EnergyModeEnumType &dst);

enum class UnitOfMeasurementEnumType {
	unknown,
	var_1,
	m,
	kg,
	s,
	A,
	K,
	mol,
	cd,
	V,
	W,
	Wh,
	VA,
	VAh,
	var,
	varh,
	degC,
	degF,
	Lm,
	lx,
	Ohm,
	Hz,
	dB,
	dBm,
	pct,
	ppm,
	l,
	l_s,
	l_h,
	deg,
	rad,
	rad_s,
	sr,
	Gy,
	Bq,
	Bq_m_3,
	Sv,
	Rd,
	C,
	F,
	H,
	J,
	N,
	N_m,
	N_s,
	Wb,
	T,
	Pa,
	bar,
	atm,
	psi,
	mmHg,
	m_2,
	m_3,
	m_3_h,
	m_s,
	m_s_2,
	m_3_s,
	m_m_3,
	kg_m_3,
	kg_m,
	m_2_s,
	W_m_K,
	J_K,
	var_1_s,
	W_m_2,
	J_m_2,
	S,
	S_m,
	K_s,
	Pa_s,
	J_kg_K,
	Vs,
	V_m,
	V_Hz,
	As,
	A_m,
	Hz_s,
	kg_s,
	kg_m_2,
	J_Wh,
	W_s,
	ft_3,
	ft_3_h,
	ccf,
	ccf_h,
	US_liq_gal,
	US_liq_gal_h,
	Imp_gal,
	Imp_gal_h,
	Btu,
	Btu_h,
	Ah,
	kg_Wh,
};
bool convertToJson(const UnitOfMeasurementEnumType &src, JsonVariant& dst);
void convertFromJson(const JsonVariantConst& src, UnitOfMeasurementEnumType &dst);

enum class CurrencyEnumType {
	AED,
	AFN,
	ALL,
	AMD,
	ANG,
	AOA,
	ARS,
	AUD,
	AWG,
	AZN,
	BAM,
	BBD,
	BDT,
	BGN,
	BHD,
	BIF,
	BMD,
	BND,
	BOB,
	BOV,
	BRL,
	BSD,
	BTN,
	BWP,
	BYR,
	BZD,
	CAD,
	CDF,
	CHE,
	CHF,
	CHW,
	CLF,
	CLP,
	CNY,
	COP,
	COU,
	CRC,
	CUC,
	CUP,
	CVE,
	CZK,
	DJF,
	DKK,
	DOP,
	DZD,
	EGP,
	ERN,
	ETB,
	EUR,
	FJD,
	FKP,
	GBP,
	GEL,
	GHS,
	GIP,
	GMD,
	GNF,
	GTQ,
	GYD,
	HKD,
	HNL,
	HRK,
	HTG,
	HUF,
	IDR,
	ILS,
	INR,
	IQD,
	IRR,
	ISK,
	JMD,
	JOD,
	JPY,
	KES,
	KGS,
	KHR,
	KMF,
	KPW,
	KRW,
	KWD,
	KYD,
	KZT,
	LAK,
	LBP,
	LKR,
	LRD,
	LSL,
	LYD,
	MAD,
	MDL,
	MGA,
	MKD,
	MMK,
	MNT,
	MOP,
	MRO,
	MUR,
	MVR,
	MWK,
	MXN,
	MXV,
	MYR,
	MZN,
	NAD,
	NGN,
	NIO,
	NOK,
	NPR,
	NZD,
	OMR,
	PAB,
	PEN,
	PGK,
	PHP,
	PKR,
	PLN,
	PYG,
	QAR,
	RON,
	RSD,
	RUB,
	RWF,
	SAR,
	SBD,
	SCR,
	SDG,
	SEK,
	SGD,
	SHP,
	SLL,
	SOS,
	SRD,
	SSP,
	STD,
	SVC,
	SYP,
	SZL,
	THB,
	TJS,
	TMT,
	TND,
	TOP,
	TRY,
	TTD,
	TWD,
	TZS,
	UAH,
	UGX,
	USD,
	USN,
	UYI,
	UYU,
	UZS,
	VEF,
	VND,
	VUV,
	WST,
	XAF,
	XAG,
	XAU,
	XBA,
	XBB,
	XBC,
	XBD,
	XCD,
	XDR,
	XOF,
	XPD,
	XPF,
	XPT,
	XSU,
	XTS,
	XUA,
	XXX,
	YER,
	ZAR,
	ZMW,
	ZWL,
};
bool convertToJson(const CurrencyEnumType &src, JsonVariant& dst);
void convertFromJson(const JsonVariantConst& src, CurrencyEnumType &dst);

enum class ScopeTypeEnumType {
	ac,
	acCosPhiGrid,
	acCurrentA,
	acCurrentB,
	acCurrentC,
	acFrequencyGrid,
	acPowerA,
	acPowerB,
	acPowerC,
	acPowerLimitPct,
	acPowerTotal,
	acVoltageA,
	acVoltageB,
	acVoltageC,
	acYieldDay,
	acYieldTotal,
	dcCurrent,
	dcPower,
	dcString1,
	dcString2,
	dcString3,
	dcString4,
	dcString5,
	dcString6,
	dcTotal,
	dcVoltage,
	dhwTemperature,
	flowTemperature,
	outsideAirTemperature,
	returnTemperature,
	roomAirTemperature,
	charge,
	stateOfCharge,
	discharge,
	gridConsumption,
	gridFeedIn,
	selfConsumption,
	overloadProtection,
	acPower,
	acEnergy,
	acCurrent,
	acVoltage,
	batteryControl,
	simpleIncentiveTable,
	stateOfHealth,
	travelRange,
	nominalEnergyCapacity,
	acPowerReal,
	acPowerApparent,
	acPowerReactive,
	acYieldMonth,
	acYieldYear,
	acFrequency,
	acCosPhi,
	dcEnergy,
	insulationResistance,
	stateOfEnergy,
	useableCapacity,
	dcChargeEnergy,
	dcDischargeEnergy,
	loadCycleCount,
	componentTemperature,
	gridLimit,
	gridLimitFallback,
	acPowerApparentTotal,
	acPowerReactiveTotal,
	acCurrentTotal,
	acEnergyConsumed,
	acEnergyProduced,
	batteryAcPower,
	batteryAcPowerPhaseSpecific,
	batteryDcPower,
	pccPower,
	activePowerLimit,
	activePowerLimitPercentage,
	simpleCommittedIncentiveTable,
	simplePreliminaryIncentiveTable,
	committedPowerPlan,
	preliminaryPowerPlan,
	incentiveTableEnConsWithPoETF,
	incentiveTableEnProdWithPoETF,
	incentiveTableEnConsWithPoE,
	incentiveTableEnProdWithPoE,
	incentiveTableEnConsWithTF,
	incentiveTableEnProdWithTF,
	activePowerForecast,
};
bool convertToJson(const ScopeTypeEnumType &src, JsonVariant& dst);
void convertFromJson(const JsonVariantConst& src, ScopeTypeEnumType &dst);

enum class RoleType {
	client,
	server,
	special,
};
bool convertToJson(const RoleType &src, JsonVariant& dst);
void convertFromJson(const JsonVariantConst& src, RoleType &dst);

enum class DeviceTypeEnumType {
	Dishwasher,
	Dryer,
	EnvironmentSensor,
	Generic,
	HeatGenerationSystem,
	HeatSinkSystem,
	HeatStorageSystem,
	HVACController,
	SubMeter,
	Washer,
	ElectricitySupplySystem,
	EnergyManagementSystem,
	Inverter,
	ChargingStation,
};
bool convertToJson(const DeviceTypeEnumType &src, JsonVariant& dst);
void convertFromJson(const JsonVariantConst& src, DeviceTypeEnumType &dst);

enum class EntityTypeEnumType {
	Battery,
	Compressor,
	DeviceInformation,
	DHWCircuit,
	DHWStorage,
	Dishwasher,
	Dryer,
	ElectricalImmersionHeater,
	Fan,
	GasHeatingAppliance,
	Generic,
	HeatingBufferStorage,
	HeatingCircuit,
	HeatingObject,
	HeatingZone,
	HeatPumpAppliance,
	HeatSinkCircuit,
	HeatSourceCircuit,
	HeatSourceUnit,
	HVACController,
	HVACRoom,
	InstantDHWHeater,
	Inverter,
	OilHeatingAppliance,
	Pump,
	RefrigerantCircuit,
	SmartEnergyAppliance,
	SolarDHWStorage,
	SolarThermalCircuit,
	SubMeterElectricity,
	TemperatureSensor,
	Washer,
	BatterySystem,
	ElectricityGenerationSystem,
	ElectricityStorageSystem,
	GridConnectionPointOfPremises,
	Household,
	PVSystem,
	EV,
	EVSE,
	ChargingOutlet,
	CEM,
	PV,
	PVESHybrid,
	ElectricalStorage,
	PVString,
	GridGuard,
	ControllableSystem,
};
bool convertToJson(const EntityTypeEnumType &src, JsonVariant& dst);
void convertFromJson(const JsonVariantConst& src, EntityTypeEnumType &dst);

enum class FeatureTypeEnumType {
	ActuatorLevel,
	ActuatorSwitch,
	Alarm,
	DataTunneling,
	DeviceClassification,
	DeviceDiagnosis,
	DirectControl,
	ElectricalConnection,
	Generic,
	HVAC,
	LoadControl,
	Measurement,
	Messaging,
	NetworkManagement,
	NodeManagement,
	OperatingConstraints,
	PowerSequences,
	Sensing,
	Setpoint,
	SmartEnergyManagementPs,
	TaskManagement,
	Threshold,
	TimeInformation,
	TimeTable,
	DeviceConfiguration,
	SupplyCondition,
	TimeSeries,
	TariffInformation,
	IncentiveTable,
	Bill,
	Identification,
	StateInformation,
};
bool convertToJson(const FeatureTypeEnumType &src, JsonVariant& dst);
void convertFromJson(const JsonVariantConst& src, FeatureTypeEnumType &dst);

enum class FeatureDirectControlSpecificUsageEnumType {
	History,
	RealTime,
};
bool convertToJson(const FeatureDirectControlSpecificUsageEnumType &src, JsonVariant& dst);
void convertFromJson(const JsonVariantConst& src, FeatureDirectControlSpecificUsageEnumType &dst);

enum class FeatureHvacSpecificUsageEnumType {
	OperationMode,
	Overrun,
};
bool convertToJson(const FeatureHvacSpecificUsageEnumType &src, JsonVariant& dst);
void convertFromJson(const JsonVariantConst& src, FeatureHvacSpecificUsageEnumType &dst);

enum class FeatureMeasurementSpecificUsageEnumType {
	Contact,
	Electrical,
	Heat,
	Level,
	Pressure,
	Temperature,
};
bool convertToJson(const FeatureMeasurementSpecificUsageEnumType &src, JsonVariant& dst);
void convertFromJson(const JsonVariantConst& src, FeatureMeasurementSpecificUsageEnumType &dst);

enum class FeatureSetpointSpecificUsageEnumType {
	Contact,
	Electrical,
	Heat,
	Level,
	Pressure,
	Temperature,
};
bool convertToJson(const FeatureSetpointSpecificUsageEnumType &src, JsonVariant& dst);
void convertFromJson(const JsonVariantConst& src, FeatureSetpointSpecificUsageEnumType &dst);

enum class FeatureSmartEnergyManagementPsSpecificUsageEnumType {
	FixedForecast,
	FlexibleChosenForecast,
	FlexibleOptionalForecast,
	OptionalSequenceBasedImmediateControl,
};
bool convertToJson(const FeatureSmartEnergyManagementPsSpecificUsageEnumType &src, JsonVariant& dst);
void convertFromJson(const JsonVariantConst& src, FeatureSmartEnergyManagementPsSpecificUsageEnumType &dst);

enum class FunctionEnumType {
	actuatorLevelData,
	actuatorLevelDescriptionData,
	actuatorSwitchData,
	actuatorSwitchDescriptionData,
	alarmListData,
	bindingManagementDeleteCall,
	bindingManagementEntryListData,
	bindingManagementRequestCall,
	dataTunnelingCall,
	deviceClassificationManufacturerData,
	deviceClassificationUserData,
	deviceDiagnosisHeartbeatData,
	deviceDiagnosisServiceData,
	deviceDiagnosisStateData,
	directControlActivityListData,
	directControlDescriptionData,
	electricalConnectionDescriptionListData,
	electricalConnectionParameterDescriptionListData,
	electricalConnectionStateListData,
	hvacOperationModeDescriptionListData,
	hvacOverrunDescriptionListData,
	hvacOverrunListData,
	hvacSystemFunctionDescriptionListData,
	hvacSystemFunctionListData,
	hvacSystemFunctionOperationModeRelationListData,
	hvacSystemFunctionPowerSequenceRelationListData,
	hvacSystemFunctionSetpointRelationListData,
	loadControlEventListData,
	loadControlStateListData,
	measurementConstraintsListData,
	measurementDescriptionListData,
	measurementListData,
	measurementThresholdRelationListData,
	messagingListData,
	networkManagementAbortCall,
	networkManagementAddNodeCall,
	networkManagementDeviceDescriptionListData,
	networkManagementDiscoverCall,
	networkManagementEntityDescriptionListData,
	networkManagementFeatureDescriptionListData,
	networkManagementJoiningModeData,
	networkManagementModifyNodeCall,
	networkManagementProcessStateData,
	networkManagementRemoveNodeCall,
	networkManagementReportCandidateData,
	networkManagementScanNetworkCall,
	nodeManagementBindingData,
	nodeManagementBindingDeleteCall,
	nodeManagementBindingRequestCall,
	nodeManagementDestinationListData,
	nodeManagementDetailedDiscoveryData,
	nodeManagementSubscriptionData,
	nodeManagementSubscriptionDeleteCall,
	nodeManagementSubscriptionRequestCall,
	operatingConstraintsDurationListData,
	operatingConstraintsInterruptListData,
	operatingConstraintsPowerDescriptionListData,
	operatingConstraintsPowerLevelListData,
	operatingConstraintsPowerRangeListData,
	operatingConstraintsResumeImplicationListData,
	powerSequenceAlternativesRelationListData,
	powerSequenceDescriptionListData,
	powerSequenceNodeScheduleInformationData,
	powerSequencePriceCalculationRequestCall,
	powerSequencePriceListData,
	powerSequenceScheduleConfigurationRequestCall,
	powerSequenceScheduleConstraintsListData,
	powerSequenceScheduleListData,
	powerSequenceSchedulePreferenceListData,
	powerSequenceStateListData,
	powerTimeSlotScheduleConstraintsListData,
	powerTimeSlotScheduleListData,
	powerTimeSlotValueListData,
	resultData,
	sensingDescriptionData,
	sensingListData,
	sessionIdentificationListData,
	sessionMeasurementRelationListData,
	setpointConstraintsListData,
	setpointDescriptionListData,
	setpointListData,
	smartEnergyManagementPsConfigurationRequestCall,
	smartEnergyManagementPsData,
	smartEnergyManagementPsPriceCalculationRequestCall,
	smartEnergyManagementPsPriceData,
	specificationVersionListData,
	subscriptionManagementDeleteCall,
	subscriptionManagementEntryListData,
	subscriptionManagementRequestCall,
	supplyConditionDescriptionListData,
	supplyConditionListData,
	supplyConditionThresholdRelationListData,
	taskManagementJobDescriptionListData,
	taskManagementJobListData,
	taskManagementJobRelationListData,
	taskManagementOverviewData,
	thresholdConstraintsListData,
	thresholdDescriptionListData,
	thresholdListData,
	timeDistributorData,
	timeDistributorEnquiryCall,
	timeInformationData,
	timePrecisionData,
	timeTableConstraintsListData,
	timeTableDescriptionListData,
	timeTableListData,
	deviceConfigurationKeyValueConstraintsListData,
	deviceConfigurationKeyValueListData,
	deviceConfigurationKeyValueDescriptionListData,
	loadControlLimitConstraintsListData,
	loadControlLimitDescriptionListData,
	loadControlLimitListData,
	loadControlNodeData,
	timeSeriesConstraintsListData,
	timeSeriesDescriptionListData,
	timeSeriesListData,
	tariffOverallConstraintsData,
	tariffListData,
	tariffBoundaryRelationListData,
	tariffTierRelationListData,
	tariffDescriptionListData,
	tierBoundaryListData,
	tierBoundaryDescriptionListData,
	commodityListData,
	tierListData,
	tierIncentiveRelationListData,
	tierDescriptionListData,
	incentiveListData,
	incentiveDescriptionListData,
	incentiveTableData,
	incentiveTableDescriptionData,
	incentiveTableConstraintsData,
	electricalConnectionPermittedValueSetListData,
	useCaseInformationListData,
	nodeManagementUseCaseData,
	billConstraintsListData,
	billDescriptionListData,
	billListData,
	identificationListData,
	measurementSeriesListData,
	electricalConnectionCharacteristicListData,
	stateInformationListData,
};
bool convertToJson(const FunctionEnumType &src, JsonVariant& dst);
void convertFromJson(const JsonVariantConst& src, FunctionEnumType &dst);

enum class TimeSeriesTypeEnumType {
	plan,
	singleDemand,
	constraints,
	energyRequest,
	dischargingEnergyRequest,
	consumptionLimitCurve,
	productionLimitCurve,
};
bool convertToJson(const TimeSeriesTypeEnumType &src, JsonVariant& dst);
void convertFromJson(const JsonVariantConst& src, TimeSeriesTypeEnumType &dst);

enum class MeasurementTypeEnumType {
	acceleration,
	angle,
	angularVelocity,
	area,
	atmosphericPressure,
	capacity,
	concentration,
	count,
	current,
	density,
	distance,
	electricField,
	energy,
	force,
	frequency,
	harmonicDistortion,
	heat,
	heatFlux,
	illuminance,
	impulse,
	level,
	magneticField,
	mass,
	massFlow,
	particles,
	percentage,
	power,
	powerFactor,
	pressure,
	radonActivity,
	relativeHumidity,
	resistance,
	solarRadiation,
	speed,
	temperature,
	time,
	torque,
	unknown,
	velocity,
	voltage,
	volume,
	volumetricFlow,
};
bool convertToJson(const MeasurementTypeEnumType &src, JsonVariant& dst);
void convertFromJson(const JsonVariantConst& src, MeasurementTypeEnumType &dst);

enum class MeasurementValueTypeEnumType {
	value,
	averageValue,
	minValue,
	maxValue,
	standardDeviation,
};
bool convertToJson(const MeasurementValueTypeEnumType &src, JsonVariant& dst);
void convertFromJson(const JsonVariantConst& src, MeasurementValueTypeEnumType &dst);

enum class MeasurementValueSourceEnumType {
	measuredValue,
	calculatedValue,
	empiricalValue,
};
bool convertToJson(const MeasurementValueSourceEnumType &src, JsonVariant& dst);
void convertFromJson(const JsonVariantConst& src, MeasurementValueSourceEnumType &dst);

enum class MeasurementValueTendencyEnumType {
	rising,
	stable,
	falling,
};
bool convertToJson(const MeasurementValueTendencyEnumType &src, JsonVariant& dst);
void convertFromJson(const JsonVariantConst& src, MeasurementValueTendencyEnumType &dst);

enum class MeasurementValueStateEnumType {
	normal,
	outOfRange,
	error,
};
bool convertToJson(const MeasurementValueStateEnumType &src, JsonVariant& dst);
void convertFromJson(const JsonVariantConst& src, MeasurementValueStateEnumType &dst);

enum class ThresholdTypeEnumType {
	goodAbove,
	badAbove,
	goodBelow,
	badBelow,
	minValueThreshold,
	maxValueThreshold,
	minValueThresholdExtreme,
	maxValueThresholdExtreme,
	sagThreshold,
	swellThreshold,
};
bool convertToJson(const ThresholdTypeEnumType &src, JsonVariant& dst);
void convertFromJson(const JsonVariantConst& src, ThresholdTypeEnumType &dst);

enum class DirectControlActivityStateEnumType {
	running,
	paused,
	inactive,
};
bool convertToJson(const DirectControlActivityStateEnumType &src, JsonVariant& dst);
void convertFromJson(const JsonVariantConst& src, DirectControlActivityStateEnumType &dst);

enum class PowerTimeSlotValueTypeEnumType {
	power,
	powerMin,
	powerMax,
	powerExpectedValue,
	powerStandardDeviation,
	powerSkewness,
	energy,
	energyMin,
	energyMax,
	energyExpectedValue,
	energyStandardDeviation,
	energySkewness,
};
bool convertToJson(const PowerTimeSlotValueTypeEnumType &src, JsonVariant& dst);
void convertFromJson(const JsonVariantConst& src, PowerTimeSlotValueTypeEnumType &dst);

enum class PowerSequenceScopeEnumType {
	forecast,
	measurement,
	recommendation,
};
bool convertToJson(const PowerSequenceScopeEnumType &src, JsonVariant& dst);
void convertFromJson(const JsonVariantConst& src, PowerSequenceScopeEnumType &dst);

enum class PowerSequenceStateEnumType {
	running,
	paused,
	scheduled,
	scheduledPaused,
	pending,
	inactive,
	completed,
	invalid,
};
bool convertToJson(const PowerSequenceStateEnumType &src, JsonVariant& dst);
void convertFromJson(const JsonVariantConst& src, PowerSequenceStateEnumType &dst);

enum class ActuatorLevelFctEnumType {
	start,
	up,
	down,
	stop,
	percentageAbsolute,
	percentageRelative,
	absolute,
	relative,
};
bool convertToJson(const ActuatorLevelFctEnumType &src, JsonVariant& dst);
void convertFromJson(const JsonVariantConst& src, ActuatorLevelFctEnumType &dst);

enum class CmdClassifierType {
	read,
	reply,
	notify,
	write,
	call,
	result,
};
bool convertToJson(const CmdClassifierType &src, JsonVariant& dst);
void convertFromJson(const JsonVariantConst& src, CmdClassifierType &dst);

enum class ActuatorSwitchFctEnumType {
	on,
	off,
	toggle,
};
bool convertToJson(const ActuatorSwitchFctEnumType &src, JsonVariant& dst);
void convertFromJson(const JsonVariantConst& src, ActuatorSwitchFctEnumType &dst);

enum class AlarmTypeEnumType {
	alarmCancelled,
	underThreshold,
	overThreshold,
};
bool convertToJson(const AlarmTypeEnumType &src, JsonVariant& dst);
void convertFromJson(const JsonVariantConst& src, AlarmTypeEnumType &dst);

enum class BillTypeEnumType {
	chargingSummary,
};
bool convertToJson(const BillTypeEnumType &src, JsonVariant& dst);
void convertFromJson(const JsonVariantConst& src, BillTypeEnumType &dst);

enum class BillPositionTypeEnumType {
	gridElectricEnergy,
	selfProducedElectricEnergy,
};
bool convertToJson(const BillPositionTypeEnumType &src, JsonVariant& dst);
void convertFromJson(const JsonVariantConst& src, BillPositionTypeEnumType &dst);

enum class BillCostTypeEnumType {
	absolutePrice,
	relativePrice,
	co2Emission,
	renewableEnergy,
	radioactiveWaste,
};
bool convertToJson(const BillCostTypeEnumType &src, JsonVariant& dst);
void convertFromJson(const JsonVariantConst& src, BillCostTypeEnumType &dst);

enum class IdentificationTypeEnumType {
	eui48,
	eui64,
	userRfidTag,
};
bool convertToJson(const IdentificationTypeEnumType &src, JsonVariant& dst);
void convertFromJson(const JsonVariantConst& src, IdentificationTypeEnumType &dst);

enum class PowerSourceEnumType {
	unknown,
	mainsSinglePhase,
	mains3Phase,
	battery,
	dc,
};
bool convertToJson(const PowerSourceEnumType &src, JsonVariant& dst);
void convertFromJson(const JsonVariantConst& src, PowerSourceEnumType &dst);

enum class DeviceConfigurationKeyNameEnumType {
	peakPowerOfPvSystem,
	pvCurtailmentLimitFactor,
	asymmetricChargingSupported,
	communicationsStandard,
	inverterGridCode,
	pvStringAvailabilityStatus,
	batteryAvailabilityStatus,
	gridConnectionStatus,
	timeToAcChargePowerMax,
	timeToAcDischargePowerMax,
	tilt,
	azimuth,
	batteryType,
	maxCycleCountPerDay,
	failsafeConsumptionActivePowerLimit,
	failsafeProductionActivePowerLimit,
	failsafePositiveReactivePowerLimit,
	failsafeNegativeReactivePowerLimit,
	failsafePositiveCosPhiLimit,
	failsafeNegativeCosPhiLimit,
	maxAcChargePower,
	maxAcDischargePower,
	maxDcChargePower,
	maxDcDischargePower,
	batteryActiveControlMode,
	defaultAcPower,
	defaultDcPower,
	defaultPccPower,
	failsafeAcPowerSetpoint,
	failsafeDcPowerSetpoint,
	failsafePccPowerSetpoint,
	failsafeDurationMinimum,
	dischargingBelowTargetEnergyRequestPermitted,
	incentivesSimulationCyclesMax,
	incentivesSimulationConcurrent,
	incentivesTimeoutIncentiveRequest,
	incentivesWaitIncentiveWriteable,
};
bool convertToJson(const DeviceConfigurationKeyNameEnumType &src, JsonVariant& dst);
void convertFromJson(const JsonVariantConst& src, DeviceConfigurationKeyNameEnumType &dst);

enum class DeviceConfigurationKeyValueTypeType {
	boolean,
	date,
	dateTime,
	duration,
	string,
	time,
	scaledNumber,
	integer,
};
bool convertToJson(const DeviceConfigurationKeyValueTypeType &src, JsonVariant& dst);
void convertFromJson(const JsonVariantConst& src, DeviceConfigurationKeyValueTypeType &dst);

enum class DeviceDiagnosisOperatingStateEnumType {
	normalOperation,
	standby,
	failure,
	serviceNeeded,
	overrideDetected,
	inAlarm,
	notReachable,
	finished,
	temporarilyNotReady,
	off,
};
bool convertToJson(const DeviceDiagnosisOperatingStateEnumType &src, JsonVariant& dst);
void convertFromJson(const JsonVariantConst& src, DeviceDiagnosisOperatingStateEnumType &dst);

enum class PowerSupplyConditionEnumType {
	good,
	low,
	critical,
	unknown,
	error,
};
bool convertToJson(const PowerSupplyConditionEnumType &src, JsonVariant& dst);
void convertFromJson(const JsonVariantConst& src, PowerSupplyConditionEnumType &dst);

enum class ElectricalConnectionMeasurandVariantEnumType {
	amplitude,
	rms,
	instantaneous,
	angle,
	cosPhi,
};
bool convertToJson(const ElectricalConnectionMeasurandVariantEnumType &src, JsonVariant& dst);
void convertFromJson(const JsonVariantConst& src, ElectricalConnectionMeasurandVariantEnumType &dst);

enum class ElectricalConnectionVoltageTypeEnumType {
	ac,
	dc,
};
bool convertToJson(const ElectricalConnectionVoltageTypeEnumType &src, JsonVariant& dst);
void convertFromJson(const JsonVariantConst& src, ElectricalConnectionVoltageTypeEnumType &dst);

enum class ElectricalConnectionAcMeasurementTypeEnumType {
	real,
	reactive,
	apparent,
	phase,
};
bool convertToJson(const ElectricalConnectionAcMeasurementTypeEnumType &src, JsonVariant& dst);
void convertFromJson(const JsonVariantConst& src, ElectricalConnectionAcMeasurementTypeEnumType &dst);

enum class ElectricalConnectionPhaseNameEnumType {
	a,
	b,
	c,
	ab,
	bc,
	ac,
	abc,
	neutral,
	ground,
	none,
};
bool convertToJson(const ElectricalConnectionPhaseNameEnumType &src, JsonVariant& dst);
void convertFromJson(const JsonVariantConst& src, ElectricalConnectionPhaseNameEnumType &dst);

enum class ElectricalConnectionConnectionPointType {
	grid,
	home,
	pv,
	sd,
	other,
};
bool convertToJson(const ElectricalConnectionConnectionPointType &src, JsonVariant& dst);
void convertFromJson(const JsonVariantConst& src, ElectricalConnectionConnectionPointType &dst);

enum class ElectricalConnectionCharacteristicContextEnumType {
	device,
	entity,
	inverter,
	pvString,
	battery,
};
bool convertToJson(const ElectricalConnectionCharacteristicContextEnumType &src, JsonVariant& dst);
void convertFromJson(const JsonVariantConst& src, ElectricalConnectionCharacteristicContextEnumType &dst);

enum class ElectricalConnectionCharacteristicTypeEnumType {
	powerConsumptionMin,
	powerConsumptionMax,
	powerConsumptionNominalMin,
	powerConsumptionNominalMax,
	powerProductionMin,
	powerProductionMax,
	powerProductionNominalMin,
	powerProductionNominalMax,
	energyCapacityNominalMax,
	contractualConsumptionNominalMax,
	contractualProductionNominalMax,
	apparentPowerProductionNominalMax,
	apparentPowerConsumptionNominalMax,
};
bool convertToJson(const ElectricalConnectionCharacteristicTypeEnumType &src, JsonVariant& dst);
void convertFromJson(const JsonVariantConst& src, ElectricalConnectionCharacteristicTypeEnumType &dst);

enum class HvacSystemFunctionTypeEnumType {
	heating,
	cooling,
	ventilation,
	dhw,
};
bool convertToJson(const HvacSystemFunctionTypeEnumType &src, JsonVariant& dst);
void convertFromJson(const JsonVariantConst& src, HvacSystemFunctionTypeEnumType &dst);

enum class HvacOperationModeTypeEnumType {
	auto,
	on,
	off,
	eco,
};
bool convertToJson(const HvacOperationModeTypeEnumType &src, JsonVariant& dst);
void convertFromJson(const JsonVariantConst& src, HvacOperationModeTypeEnumType &dst);

enum class HvacOverrunTypeEnumType {
	oneTimeDhw,
	party,
	sgReadyCondition1,
	sgReadyCondition3,
	sgReadyCondition4,
	oneDayAway,
	oneDayAtHome,
	oneTimeVentilation,
	hvacSystemOff,
	valveKick,
};
bool convertToJson(const HvacOverrunTypeEnumType &src, JsonVariant& dst);
void convertFromJson(const JsonVariantConst& src, HvacOverrunTypeEnumType &dst);

enum class HvacOverrunStatusEnumType {
	active,
	running,
	finished,
	inactive,
};
bool convertToJson(const HvacOverrunStatusEnumType &src, JsonVariant& dst);
void convertFromJson(const JsonVariantConst& src, HvacOverrunStatusEnumType &dst);

enum class SetpointTypeEnumType {
	valueAbsolute,
	valueRelative,
};
bool convertToJson(const SetpointTypeEnumType &src, JsonVariant& dst);
void convertFromJson(const JsonVariantConst& src, SetpointTypeEnumType &dst);

enum class TimeSlotTimeModeEnumType {
	absolute,
	recurring,
	both,
};
bool convertToJson(const TimeSlotTimeModeEnumType &src, JsonVariant& dst);
void convertFromJson(const JsonVariantConst& src, TimeSlotTimeModeEnumType &dst);

enum class TierBoundaryTypeEnumType {
	powerBoundary,
	energyBoundary,
	countBoundary,
};
bool convertToJson(const TierBoundaryTypeEnumType &src, JsonVariant& dst);
void convertFromJson(const JsonVariantConst& src, TierBoundaryTypeEnumType &dst);

enum class TierTypeEnumType {
	fixedCost,
	dynamicCost,
};
bool convertToJson(const TierTypeEnumType &src, JsonVariant& dst);
void convertFromJson(const JsonVariantConst& src, TierTypeEnumType &dst);

enum class IncentiveTypeEnumType {
	absoluteCost,
	relativeCost,
	renewableEnergyPercentage,
	co2Emission,
};
bool convertToJson(const IncentiveTypeEnumType &src, JsonVariant& dst);
void convertFromJson(const JsonVariantConst& src, IncentiveTypeEnumType &dst);

enum class IncentiveValueTypeEnumType {
	value,
	averageValue,
	minValue,
	maxValue,
};
bool convertToJson(const IncentiveValueTypeEnumType &src, JsonVariant& dst);
void convertFromJson(const JsonVariantConst& src, IncentiveValueTypeEnumType &dst);

enum class LoadControlEventActionEnumType {
	pause,
	resume,
	reduce,
	increase,
	emergency,
	normal,
};
bool convertToJson(const LoadControlEventActionEnumType &src, JsonVariant& dst);
void convertFromJson(const JsonVariantConst& src, LoadControlEventActionEnumType &dst);

enum class LoadControlEventStateEnumType {
	eventAccepted,
	eventStarted,
	eventStopped,
	eventRejected,
	eventCancelled,
	eventError,
};
bool convertToJson(const LoadControlEventStateEnumType &src, JsonVariant& dst);
void convertFromJson(const JsonVariantConst& src, LoadControlEventStateEnumType &dst);

enum class LoadControlLimitTypeEnumType {
	minValueLimit,
	maxValueLimit,
	signDependentAbsValueLimit,
};
bool convertToJson(const LoadControlLimitTypeEnumType &src, JsonVariant& dst);
void convertFromJson(const JsonVariantConst& src, LoadControlLimitTypeEnumType &dst);

enum class LoadControlCategoryEnumType {
	obligation,
	recommendation,
	optimization,
};
bool convertToJson(const LoadControlCategoryEnumType &src, JsonVariant& dst);
void convertFromJson(const JsonVariantConst& src, LoadControlCategoryEnumType &dst);

enum class NetworkManagementFeatureSetType {
	gateway,
	router,
	smart,
	simple,
};
bool convertToJson(const NetworkManagementFeatureSetType &src, JsonVariant& dst);
void convertFromJson(const JsonVariantConst& src, NetworkManagementFeatureSetType &dst);

enum class NetworkManagementProcessStateStateType {
	succeeded,
	failed,
	aborted,
};
bool convertToJson(const NetworkManagementProcessStateStateType &src, JsonVariant& dst);
void convertFromJson(const JsonVariantConst& src, NetworkManagementProcessStateStateType &dst);

enum class NetworkManagementStateChangeType {
	added,
	removed,
	modified,
};
bool convertToJson(const NetworkManagementStateChangeType &src, JsonVariant& dst);
void convertFromJson(const JsonVariantConst& src, NetworkManagementStateChangeType &dst);

enum class SensingStateEnumType {
	on,
	off,
	toggle,
	level,
	levelUp,
	levelDown,
	levelStart,
	levelStop,
	levelAbsolute,
	levelRelative,
	levelPercentageAbsolute,
	levelPercentageRelative,
	pressed,
	longPressed,
	released,
	changed,
	started,
	stopped,
	paused,
	middle,
	up,
	down,
	forward,
	backwards,
	open,
	closed,
	opening,
	closing,
	high,
	low,
	day,
	night,
	detected,
	notDetected,
	alarmed,
	notAlarmed,
};
bool convertToJson(const SensingStateEnumType &src, JsonVariant& dst);
void convertFromJson(const JsonVariantConst& src, SensingStateEnumType &dst);

enum class SensingTypeEnumType {
	switch,
	button,
	level,
	levelSwitch,
	windowHandle,
	contactSensor,
	occupancySensor,
	motionDetector,
	fireDetector,
	smokeDetector,
	heatDetector,
	waterDetector,
	gasDetector,
	alarmSensor,
	powerAlarmSensor,
	dayNightIndicator,
};
bool convertToJson(const SensingTypeEnumType &src, JsonVariant& dst);
void convertFromJson(const JsonVariantConst& src, SensingTypeEnumType &dst);

enum class StateInformationFunctionalityEnumType {
	externalOverrideFromGrid,
	autonomousGridSupport,
	islandingMode,
	balancing,
	trickleCharging,
	calibration,
	commissioningMissing,
	sleeping,
	starting,
	mppt,
	throttled,
	shuttingDown,
	manualShutdown,
};
bool convertToJson(const StateInformationFunctionalityEnumType &src, JsonVariant& dst);
void convertFromJson(const JsonVariantConst& src, StateInformationFunctionalityEnumType &dst);

enum class StateInformationFailureEnumType {
	inverterDefective,
	batteryOvercurrentProtection,
	pvStringOvercurrentProtection,
	gridFault,
	groundFault,
	acDisconnected,
	dcDisconnected,
	cabinetOpen,
	overTemperature,
	underTemperature,
	frequencyAboveLimit,
	frequencyBelowLimit,
	acVoltageAboveLimit,
	acVoltageBelowLimit,
	dcVoltageAboveLimit,
	dcVoltageBelowLimit,
	hardwareTestFailure,
	genericInternalError,
};
bool convertToJson(const StateInformationFailureEnumType &src, JsonVariant& dst);
void convertFromJson(const JsonVariantConst& src, StateInformationFailureEnumType &dst);

enum class StateInformationCategoryEnumType {
	functionality,
	failure,
};
bool convertToJson(const StateInformationCategoryEnumType &src, JsonVariant& dst);
void convertFromJson(const JsonVariantConst& src, StateInformationCategoryEnumType &dst);

enum class SupplyConditionEventTypeEnumType {
	thesholdExceeded,
	fallenBelowThreshold,
	supplyInterrupt,
	releaseOfLimitations,
	otherProblem,
	gridConditionUpdate,
};
bool convertToJson(const SupplyConditionEventTypeEnumType &src, JsonVariant& dst);
void convertFromJson(const JsonVariantConst& src, SupplyConditionEventTypeEnumType &dst);

enum class SupplyConditionOriginatorEnumType {
	externDSO,
	externSupplier,
	internalLimit,
	internalService,
	internalUser,
};
bool convertToJson(const SupplyConditionOriginatorEnumType &src, JsonVariant& dst);
void convertFromJson(const JsonVariantConst& src, SupplyConditionOriginatorEnumType &dst);

enum class GridConditionEnumType {
	consumptionRed,
	consumptionYellow,
	good,
	productionYellow,
	productionRed,
};
bool convertToJson(const GridConditionEnumType &src, JsonVariant& dst);
void convertFromJson(const JsonVariantConst& src, GridConditionEnumType &dst);

enum class TaskManagementJobSourceEnumType {
	internalMechanism,
	userInteraction,
	externalConfiguration,
};
bool convertToJson(const TaskManagementJobSourceEnumType &src, JsonVariant& dst);
void convertFromJson(const JsonVariantConst& src, TaskManagementJobSourceEnumType &dst);

struct MessagingTypeType {
	std::optional<MessagingTypeEnumType> messagingtypeenumtype;
	std::optional<EnumExtendType> enumextendtype;
};
struct AbsoluteOrRelativeTimeType {
	std::optional<uint64_t> duration;
	std::optional<uint64_t> dateTime;
};
struct RecurringIntervalType {
	std::optional<RecurringIntervalEnumType> recurringintervalenumtype;
	std::optional<EnumExtendType> enumextendtype;
};
struct OccurrenceType {
	std::optional<OccurrenceEnumType> occurrenceenumtype;
	std::optional<EnumExtendType> enumextendtype;
};
struct CommodityTypeType {
	std::optional<CommodityTypeEnumType> commoditytypeenumtype;
	std::optional<EnumExtendType> enumextendtype;
};
struct EnergyDirectionType {
	std::optional<EnergyDirectionEnumType> energydirectionenumtype;
	std::optional<EnumExtendType> enumextendtype;
};
struct EnergyModeType {
	std::optional<EnergyModeEnumType> energymodeenumtype;
	std::optional<EnumExtendType> enumextendtype;
};
struct UnitOfMeasurementType {
	std::optional<UnitOfMeasurementEnumType> unitofmeasurementenumtype;
	std::optional<EnumExtendType> enumextendtype;
};
struct CurrencyType {
	std::optional<CurrencyEnumType> currencyenumtype;
	std::optional<EnumExtendType> enumextendtype;
};
struct ScopeTypeType {
	std::optional<ScopeTypeEnumType> scopetypeenumtype;
	std::optional<EnumExtendType> enumextendtype;
};
struct DeviceTypeType {
	std::optional<DeviceTypeEnumType> devicetypeenumtype;
	std::optional<EnumExtendType> enumextendtype;
};
struct EntityTypeType {
	std::optional<EntityTypeEnumType> entitytypeenumtype;
	std::optional<EnumExtendType> enumextendtype;
};
struct FeatureTypeType {
	std::optional<FeatureTypeEnumType> featuretypeenumtype;
	std::optional<EnumExtendType> enumextendtype;
};
struct FeatureSpecificUsageType {
	std::optional<std::string> FeatureSpecificUsageEnumType;
	std::optional<EnumExtendType> enumextendtype;
};
struct FeatureSpecificUsageEnumType {
	std::optional<FeatureDirectControlSpecificUsageEnumType> featuredirectcontrolspecificusageenumtype;
	std::optional<FeatureHvacSpecificUsageEnumType> featurehvacspecificusageenumtype;
	std::optional<FeatureMeasurementSpecificUsageEnumType> featuremeasurementspecificusageenumtype;
	std::optional<FeatureSetpointSpecificUsageEnumType> featuresetpointspecificusageenumtype;
	std::optional<FeatureSmartEnergyManagementPsSpecificUsageEnumType> featuresmartenergymanagementpsspecificusageenumtype;
};
struct FunctionType {
	std::optional<FunctionEnumType> functionenumtype;
	std::optional<EnumExtendType> enumextendtype;
};
struct MessagingDataType {
	std::optional<AbsoluteOrRelativeTimeType> timestamp ;
	std::optional<MessagingNumberType> messagingNumber ;
	std::optional<MessagingTypeType> type ;
	std::optional<MessagingDataTextType> text ;
};
struct MessagingDataElementsType {
	std::optional<ElementTagType> timestamp ;
	std::optional<ElementTagType> messagingNumber ;
	std::optional<ElementTagType> type ;
	std::optional<ElementTagType> text ;
};
struct MessagingListDataType {
	std::optional<MessagingDataType> messagingData ;
};
struct MessagingListDataSelectorsType {
	std::optional<TimestampIntervalType> timestampInterval ;
	std::optional<MessagingNumberType> messagingNumber ;
};
struct ElementTagType {
};
struct TimePeriodType {
	std::optional<AbsoluteOrRelativeTimeType> startTime ;
	std::optional<AbsoluteOrRelativeTimeType> endTime ;
};
struct TimePeriodElementsType {
	std::optional<ElementTagType> startTime ;
	std::optional<ElementTagType> endTime ;
};
struct TimestampIntervalType {
	std::optional<AbsoluteOrRelativeTimeType> startTime ;
	std::optional<AbsoluteOrRelativeTimeType> endTime ;
};
struct DaysOfWeekType {
	std::optional<ElementTagType> monday ;
	std::optional<ElementTagType> tuesday ;
	std::optional<ElementTagType> wednesday ;
	std::optional<ElementTagType> thursday ;
	std::optional<ElementTagType> friday ;
	std::optional<ElementTagType> saturday ;
	std::optional<ElementTagType> sunday ;
};
struct AbsoluteOrRecurringTimeType {
	std::optional<dateTime> dateTime ;
	std::optional<MonthType> month ;
	std::optional<DayOfMonthType> dayOfMonth ;
	std::optional<CalendarWeekType> calendarWeek ;
	std::optional<OccurrenceType> dayOfWeekOccurrence ;
	std::optional<DaysOfWeekType> daysOfWeek ;
	std::optional<time> time ;
	std::optional<duration> relative ;
};
struct AbsoluteOrRecurringTimeElementsType {
	std::optional<ElementTagType> dateTime ;
	std::optional<ElementTagType> month ;
	std::optional<ElementTagType> dayOfMonth ;
	std::optional<ElementTagType> calendarWeek ;
	std::optional<ElementTagType> dayOfWeekOccurrence ;
	std::optional<ElementTagType> daysOfWeek ;
	std::optional<ElementTagType> time ;
	std::optional<ElementTagType> relative ;
};
struct RecurrenceInformationType {
	std::optional<RecurringIntervalType> recurringInterval ;
	std::optional<unsignedInt> recurringIntervalStep ;
	std::optional<dateTime> firstExecution ;
	std::optional<unsignedInt> executionCount ;
	std::optional<dateTime> lastExecution ;
};
struct RecurrenceInformationElementsType {
	std::optional<ElementTagType> recurringInterval ;
	std::optional<ElementTagType> recurringIntervalStep ;
	std::optional<ElementTagType> firstExecution ;
	std::optional<ElementTagType> executionCount ;
	std::optional<ElementTagType> lastExecution ;
};
struct ScaledNumberRangeType {
	std::optional<ScaledNumberType> min ;
	std::optional<ScaledNumberType> max ;
};
struct ScaledNumberRangeElementsType {
	std::optional<ScaledNumberElementsType> min ;
	std::optional<ScaledNumberElementsType> max ;
};
struct ScaledNumberSetType {
	std::optional<ScaledNumberType> value ;
	std::optional<ScaledNumberRangeType> range ;
};
struct ScaledNumberSetElementsType {
	std::optional<ScaledNumberElementsType> value ;
	std::optional<ScaledNumberRangeElementsType> range ;
};
struct ScaledNumberType {
	std::optional<NumberType> number ;
	std::optional<ScaleType> scale ;
};
struct ScaledNumberElementsType {
	std::optional<ElementTagType> number ;
	std::optional<ElementTagType> scale ;
};
struct DeviceAddressType {
	std::optional<AddressDeviceType> device ;
};
struct DeviceAddressElementsType {
	std::optional<ElementTagType> device ;
};
struct EntityAddressType {
	std::optional<AddressDeviceType> device ;
	std::optional<std::vector<AddressEntityType>> entity ;
};
struct EntityAddressElementsType {
	std::optional<ElementTagType> device ;
	std::optional<ElementTagType> entity ;
};
struct FeatureAddressType {
	std::optional<AddressDeviceType> device ;
	std::optional<std::vector<AddressEntityType>> entity ;
	std::optional<AddressFeatureType> feature ;
};
struct FeatureAddressElementsType {
	std::optional<ElementTagType> device ;
	std::optional<ElementTagType> entity ;
	std::optional<ElementTagType> feature ;
};
struct PossibleOperationsClassifierType {
	std::optional<ElementTagType> partial ;
};
struct PossibleOperationsReadType {
	std::optional<ElementTagType> partial ;
};
struct PossibleOperationsWriteType {
	std::optional<ElementTagType> partial ;
};
struct PossibleOperationsType {
	std::optional<PossibleOperationsReadType> read ;
	std::optional<PossibleOperationsWriteType> write ;
};
struct PossibleOperationsElementsType {
	std::optional<ElementTagType> read ;
	std::optional<ElementTagType> write ;
};
struct FunctionPropertyType {
	std::optional<FunctionType> function ;
	std::optional<PossibleOperationsType> possibleOperations ;
};
struct FunctionPropertyElementsType {
	std::optional<ElementTagType> function ;
	std::optional<PossibleOperationsElementsType> possibleOperations ;
};
struct TimeSeriesTypeType {
	std::optional<TimeSeriesTypeEnumType> timeseriestypeenumtype;
	std::optional<EnumExtendType> enumextendtype;
};
struct MeasurementTypeType {
	std::optional<MeasurementTypeEnumType> measurementtypeenumtype;
	std::optional<EnumExtendType> enumextendtype;
};
struct MeasurementValueTypeType {
	std::optional<MeasurementValueTypeEnumType> measurementvaluetypeenumtype;
	std::optional<EnumExtendType> enumextendtype;
};
struct MeasurementValueSourceType {
	std::optional<MeasurementValueSourceEnumType> measurementvaluesourceenumtype;
	std::optional<EnumExtendType> enumextendtype;
};
struct MeasurementValueTendencyType {
	std::optional<MeasurementValueTendencyEnumType> measurementvaluetendencyenumtype;
	std::optional<EnumExtendType> enumextendtype;
};
struct MeasurementValueStateType {
	std::optional<MeasurementValueStateEnumType> measurementvaluestateenumtype;
	std::optional<EnumExtendType> enumextendtype;
};
struct ThresholdTypeType {
	std::optional<ThresholdTypeEnumType> thresholdtypeenumtype;
	std::optional<EnumExtendType> enumextendtype;
};
struct TimeSeriesSlotType {
	std::optional<TimeSeriesSlotIdType> timeSeriesSlotId ;
	std::optional<TimePeriodType> timePeriod ;
	std::optional<duration> duration ;
	std::optional<AbsoluteOrRecurringTimeType> recurrenceInformation ;
	std::optional<ScaledNumberType> value ;
	std::optional<ScaledNumberType> minValue ;
	std::optional<ScaledNumberType> maxValue ;
};
struct TimeSeriesSlotElementsType {
	std::optional<ElementTagType> timeSeriesSlotId ;
	std::optional<TimePeriodElementsType> timePeriod ;
	std::optional<ElementTagType> duration ;
	std::optional<AbsoluteOrRecurringTimeElementsType> recurrenceInformation ;
	std::optional<ElementTagType> value ;
	std::optional<ElementTagType> minValue ;
	std::optional<ElementTagType> maxValue ;
};
struct TimeSeriesDataType {
	std::optional<TimeSeriesIdType> timeSeriesId ;
	std::optional<TimePeriodType> timePeriod ;
	std::optional<TimeSeriesSlotType> timeSeriesSlot ;
};
struct TimeSeriesDataElementsType {
	std::optional<ElementTagType> timeSeriesId ;
	std::optional<TimePeriodElementsType> timePeriod ;
	std::optional<TimeSeriesSlotElementsType> timeSeriesSlot ;
};
struct TimeSeriesListDataType {
	std::optional<TimeSeriesDataType> timeSeriesData ;
};
struct TimeSeriesListDataSelectorsType {
	std::optional<TimeSeriesIdType> timeSeriesId ;
	std::optional<TimeSeriesSlotIdType> timeSeriesSlotId ;
};
struct TimeSeriesDescriptionDataType {
	std::optional<TimeSeriesIdType> timeSeriesId ;
	std::optional<TimeSeriesTypeType> timeSeriesType ;
	std::optional<boolean> timeSeriesWriteable ;
	std::optional<boolean> updateRequired ;
	std::optional<MeasurementIdType> measurementId ;
	std::optional<CurrencyType> currency ;
	std::optional<UnitOfMeasurementType> unit ;
	std::optional<LabelType> label ;
	std::optional<DescriptionType> description ;
	std::optional<ScopeTypeType> scopeType ;
};
struct TimeSeriesDescriptionDataElementsType {
	std::optional<ElementTagType> timeSeriesId ;
	std::optional<ElementTagType> timeSeriesType ;
	std::optional<ElementTagType> timeSeriesWriteable ;
	std::optional<ElementTagType> updateRequired ;
	std::optional<ElementTagType> measurementId ;
	std::optional<ElementTagType> currency ;
	std::optional<ElementTagType> unit ;
	std::optional<ElementTagType> label ;
	std::optional<ElementTagType> description ;
	std::optional<ElementTagType> scopeType ;
};
struct TimeSeriesDescriptionListDataType {
	std::optional<TimeSeriesDescriptionDataType> timeSeriesDescriptionData ;
};
struct TimeSeriesDescriptionListDataSelectorsType {
	std::optional<TimeSeriesIdType> timeSeriesId ;
	std::optional<TimeSeriesTypeType> timeSeriesType ;
	std::optional<MeasurementIdType> measurementId ;
	std::optional<ScopeTypeType> scopeType ;
};
struct TimeSeriesConstraintsDataType {
	std::optional<TimeSeriesIdType> timeSeriesId ;
	std::optional<TimeSeriesSlotCountType> slotCountMin ;
	std::optional<TimeSeriesSlotCountType> slotCountMax ;
	std::optional<duration> slotDurationMin ;
	std::optional<duration> slotDurationMax ;
	std::optional<duration> slotDurationStepSize ;
	std::optional<AbsoluteOrRelativeTimeType> earliestTimeSeriesStartTime ;
	std::optional<AbsoluteOrRelativeTimeType> latestTimeSeriesEndTime ;
	std::optional<ScaledNumberType> slotValueMin ;
	std::optional<ScaledNumberType> slotValueMax ;
	std::optional<ScaledNumberType> slotValueStepSize ;
};
struct TimeSeriesConstraintsDataElementsType {
	std::optional<ElementTagType> timeSeriesId ;
	std::optional<ElementTagType> slotCountMin ;
	std::optional<ElementTagType> slotCountMax ;
	std::optional<ElementTagType> slotDurationMin ;
	std::optional<ElementTagType> slotDurationMax ;
	std::optional<ElementTagType> slotDurationStepSize ;
	std::optional<ElementTagType> earliestTimeSeriesStartTime ;
	std::optional<ElementTagType> latestTimeSeriesEndTime ;
	std::optional<ScaledNumberElementsType> slotValueMin ;
	std::optional<ScaledNumberElementsType> slotValueMax ;
	std::optional<ScaledNumberElementsType> slotValueStepSize ;
};
struct TimeSeriesConstraintsListDataType {
	std::optional<TimeSeriesConstraintsDataType> timeSeriesConstraintsData ;
};
struct TimeSeriesConstraintsListDataSelectorsType {
	std::optional<TimeSeriesIdType> timeSeriesId ;
};
struct MeasurementDataType {
	std::optional<MeasurementIdType> measurementId ;
	std::optional<MeasurementValueTypeType> valueType ;
	std::optional<AbsoluteOrRelativeTimeType> timestamp ;
	std::optional<ScaledNumberType> value ;
	std::optional<TimePeriodType> evaluationPeriod ;
	std::optional<MeasurementValueSourceType> valueSource ;
	std::optional<MeasurementValueTendencyType> valueTendency ;
	std::optional<MeasurementValueStateType> valueState ;
};
struct MeasurementDataElementsType {
	std::optional<ElementTagType> measurementId ;
	std::optional<ElementTagType> valueType ;
	std::optional<ElementTagType> timestamp ;
	std::optional<ScaledNumberElementsType> value ;
	std::optional<TimePeriodElementsType> evaluationPeriod ;
	std::optional<ElementTagType> valueSource ;
	std::optional<ElementTagType> valueTendency ;
	std::optional<ElementTagType> valueState ;
};
struct MeasurementListDataType {
	std::optional<MeasurementDataType> measurementData ;
};
struct MeasurementListDataSelectorsType {
	std::optional<MeasurementIdType> measurementId ;
	std::optional<MeasurementValueTypeType> valueType ;
	std::optional<TimestampIntervalType> timestampInterval ;
};
struct MeasurementSeriesDataType {
	std::optional<MeasurementIdType> measurementId ;
	std::optional<MeasurementValueTypeType> valueType ;
	std::optional<AbsoluteOrRelativeTimeType> timestamp ;
	std::optional<ScaledNumberType> value ;
	std::optional<TimePeriodType> evaluationPeriod ;
	std::optional<MeasurementValueSourceType> valueSource ;
	std::optional<MeasurementValueTendencyType> valueTendency ;
	std::optional<MeasurementValueStateType> valueState ;
};
struct MeasurementSeriesDataElementsType {
	std::optional<ElementTagType> measurementId ;
	std::optional<ElementTagType> valueType ;
	std::optional<ElementTagType> timestamp ;
	std::optional<ScaledNumberElementsType> value ;
	std::optional<TimePeriodElementsType> evaluationPeriod ;
	std::optional<ElementTagType> valueSource ;
	std::optional<ElementTagType> valueTendency ;
	std::optional<ElementTagType> valueState ;
};
struct MeasurementSeriesListDataType {
	std::optional<MeasurementSeriesDataType> measurementSeriesData ;
};
struct MeasurementSeriesListDataSelectorsType {
	std::optional<MeasurementIdType> measurementId ;
	std::optional<MeasurementValueTypeType> valueType ;
	std::optional<TimestampIntervalType> timestampInterval ;
};
struct MeasurementConstraintsDataType {
	std::optional<MeasurementIdType> measurementId ;
	std::optional<ScaledNumberType> valueRangeMin ;
	std::optional<ScaledNumberType> valueRangeMax ;
	std::optional<ScaledNumberType> valueStepSize ;
};
struct MeasurementConstraintsDataElementsType {
	std::optional<ElementTagType> measurementId ;
	std::optional<ScaledNumberElementsType> valueRangeMin ;
	std::optional<ScaledNumberElementsType> valueRangeMax ;
	std::optional<ScaledNumberElementsType> valueStepSize ;
};
struct MeasurementConstraintsListDataType {
	std::optional<MeasurementConstraintsDataType> measurementConstraintsData ;
};
struct MeasurementConstraintsListDataSelectorsType {
	std::optional<MeasurementIdType> measurementId ;
};
struct MeasurementDescriptionDataType {
	std::optional<MeasurementIdType> measurementId ;
	std::optional<MeasurementTypeType> measurementType ;
	std::optional<CommodityTypeType> commodityType ;
	std::optional<UnitOfMeasurementType> unit ;
	std::optional<ScaledNumberType> calibrationValue ;
	std::optional<ScopeTypeType> scopeType ;
	std::optional<LabelType> label ;
	std::optional<DescriptionType> description ;
};
struct MeasurementDescriptionDataElementsType {
	std::optional<ElementTagType> measurementId ;
	std::optional<ElementTagType> measurementType ;
	std::optional<ElementTagType> commodityType ;
	std::optional<ElementTagType> unit ;
	std::optional<ScaledNumberElementsType> calibrationValue ;
	std::optional<ElementTagType> scopeType ;
	std::optional<ElementTagType> label ;
	std::optional<ElementTagType> description ;
};
struct MeasurementDescriptionListDataType {
	std::optional<MeasurementDescriptionDataType> measurementDescriptionData ;
};
struct MeasurementDescriptionListDataSelectorsType {
	std::optional<MeasurementIdType> measurementId ;
	std::optional<MeasurementTypeType> measurementType ;
	std::optional<CommodityTypeType> commodityType ;
	std::optional<ScopeTypeType> scopeType ;
};
struct MeasurementThresholdRelationDataType {
	std::optional<MeasurementIdType> measurementId ;
	std::optional<ThresholdIdType> thresholdId ;
};
struct MeasurementThresholdRelationDataElementsType {
	std::optional<ElementTagType> measurementId ;
	std::optional<ElementTagType> thresholdId ;
};
struct MeasurementThresholdRelationListDataType {
	std::optional<MeasurementThresholdRelationDataType> measurementThresholdRelationData ;
};
struct MeasurementThresholdRelationListDataSelectorsType {
	std::optional<MeasurementIdType> measurementId ;
	std::optional<ThresholdIdType> thresholdId ;
};
struct ThresholdDataType {
	std::optional<ThresholdIdType> thresholdId ;
	std::optional<ScaledNumberType> thresholdValue ;
};
struct ThresholdDataElementsType {
	std::optional<ElementTagType> thresholdId ;
	std::optional<ScaledNumberElementsType> thresholdValue ;
};
struct ThresholdListDataType {
	std::optional<ThresholdDataType> thresholdData ;
};
struct ThresholdListDataSelectorsType {
	std::optional<ThresholdIdType> thresholdId ;
};
struct ThresholdConstraintsDataType {
	std::optional<ThresholdIdType> thresholdId ;
	std::optional<ScaledNumberType> thresholdRangeMin ;
	std::optional<ScaledNumberType> thresholdRangeMax ;
	std::optional<ScaledNumberType> thresholdStepSize ;
};
struct ThresholdConstraintsDataElementsType {
	std::optional<ElementTagType> thresholdId ;
	std::optional<ScaledNumberElementsType> thresholdRangeMin ;
	std::optional<ScaledNumberElementsType> thresholdRangeMax ;
	std::optional<ScaledNumberElementsType> thresholdStepSize ;
};
struct ThresholdConstraintsListDataType {
	std::optional<ThresholdConstraintsDataType> thresholdConstraintsData ;
};
struct ThresholdConstraintsListDataSelectorsType {
	std::optional<ThresholdIdType> thresholdId ;
};
struct ThresholdDescriptionDataType {
	std::optional<ThresholdIdType> thresholdId ;
	std::optional<ThresholdTypeType> thresholdType ;
	std::optional<UnitOfMeasurementType> unit ;
	std::optional<ScopeTypeType> scopeType ;
	std::optional<LabelType> label ;
	std::optional<DescriptionType> description ;
};
struct ThresholdDescriptionDataElementsType {
	std::optional<ElementTagType> thresholdId ;
	std::optional<ElementTagType> thresholdType ;
	std::optional<ElementTagType> unit ;
	std::optional<ElementTagType> scopeType ;
	std::optional<ElementTagType> label ;
	std::optional<ElementTagType> description ;
};
struct ThresholdDescriptionListDataType {
	std::optional<ThresholdDescriptionDataType> thresholdDescriptionData ;
};
struct ThresholdDescriptionListDataSelectorsType {
	std::optional<ThresholdIdType> thresholdId ;
	std::optional<ScopeTypeType> scopeType ;
};
struct DirectControlActivityStateType {
	std::optional<DirectControlActivityStateEnumType> directcontrolactivitystateenumtype;
	std::optional<EnumExtendType> enumextendtype;
};
struct PowerTimeSlotValueTypeType {
	std::optional<PowerTimeSlotValueTypeEnumType> powertimeslotvaluetypeenumtype;
	std::optional<EnumExtendType> enumextendtype;
};
struct PowerSequenceScopeType {
	std::optional<PowerSequenceScopeEnumType> powersequencescopeenumtype;
	std::optional<EnumExtendType> enumextendtype;
};
struct PowerSequenceStateType {
	std::optional<PowerSequenceStateEnumType> powersequencestateenumtype;
	std::optional<EnumExtendType> enumextendtype;
};
struct DirectControlActivityDataType {
	std::optional<AbsoluteOrRelativeTimeType> timestamp ;
	std::optional<DirectControlActivityStateType> activityState ;
	std::optional<boolean> isActivityStateChangeable ;
	std::optional<EnergyModeType> energyMode ;
	std::optional<boolean> isEnergyModeChangeable ;
	std::optional<ScaledNumberType> power ;
	std::optional<boolean> isPowerChangeable ;
	std::optional<ScaledNumberType> energy ;
	std::optional<boolean> isEnergyChangeable ;
	std::optional<PowerSequenceIdType> sequenceId ;
};
struct DirectControlActivityDataElementsType {
	std::optional<ElementTagType> timestamp ;
	std::optional<ElementTagType> activityState ;
	std::optional<ElementTagType> isActivityStateChangeable ;
	std::optional<ElementTagType> energyMode ;
	std::optional<ElementTagType> isEnergyModeChangeable ;
	std::optional<ScaledNumberElementsType> power ;
	std::optional<ElementTagType> isPowerChangeable ;
	std::optional<ScaledNumberElementsType> energy ;
	std::optional<ElementTagType> isEnergyChangeable ;
	std::optional<ElementTagType> sequenceId ;
};
struct DirectControlActivityListDataType {
	std::optional<DirectControlActivityDataType> directControlActivityData ;
};
struct DirectControlActivityListDataSelectorsType {
	std::optional<TimestampIntervalType> timestampInterval ;
};
struct DirectControlDescriptionDataType {
	std::optional<EnergyDirectionType> positiveEnergyDirection ;
	std::optional<UnitOfMeasurementType> powerUnit ;
	std::optional<UnitOfMeasurementType> energyUnit ;
};
struct DirectControlDescriptionDataElementsType {
	std::optional<ElementTagType> positiveEnergyDirection ;
	std::optional<ElementTagType> powerUnit ;
	std::optional<ElementTagType> energyUnit ;
};
struct PowerTimeSlotScheduleDataType {
	std::optional<PowerSequenceIdType> sequenceId ;
	std::optional<PowerTimeSlotNumberType> slotNumber ;
	std::optional<TimePeriodType> timePeriod ;
	std::optional<duration> defaultDuration ;
	std::optional<duration> durationUncertainty ;
	std::optional<boolean> slotActivated ;
	std::optional<DescriptionType> description ;
};
struct PowerTimeSlotScheduleDataElementsType {
	std::optional<ElementTagType> sequenceId ;
	std::optional<ElementTagType> slotNumber ;
	std::optional<TimePeriodElementsType> timePeriod ;
	std::optional<ElementTagType> defaultDuration ;
	std::optional<ElementTagType> durationUncertainty ;
	std::optional<ElementTagType> slotActivated ;
	std::optional<ElementTagType> description ;
};
struct PowerTimeSlotScheduleListDataType {
	std::optional<PowerTimeSlotScheduleDataType> powerTimeSlotScheduleData ;
};
struct PowerTimeSlotScheduleListDataSelectorsType {
	std::optional<PowerSequenceIdType> sequenceId ;
	std::optional<PowerTimeSlotNumberType> slotNumber ;
};
struct PowerTimeSlotValueDataType {
	std::optional<PowerSequenceIdType> sequenceId ;
	std::optional<PowerTimeSlotNumberType> slotNumber ;
	std::optional<PowerTimeSlotValueTypeType> valueType ;
	std::optional<ScaledNumberType> value ;
};
struct PowerTimeSlotValueDataElementsType {
	std::optional<ElementTagType> sequenceId ;
	std::optional<ElementTagType> slotNumber ;
	std::optional<ElementTagType> valueType ;
	std::optional<ScaledNumberElementsType> value ;
};
struct PowerTimeSlotValueListDataType {
	std::optional<PowerTimeSlotValueDataType> powerTimeSlotValueData ;
};
struct PowerTimeSlotValueListDataSelectorsType {
	std::optional<PowerSequenceIdType> sequenceId ;
	std::optional<PowerTimeSlotNumberType> slotNumber ;
	std::optional<PowerTimeSlotValueTypeType> valueType ;
};
struct PowerTimeSlotScheduleConstraintsDataType {
	std::optional<PowerSequenceIdType> sequenceId ;
	std::optional<PowerTimeSlotNumberType> slotNumber ;
	std::optional<AbsoluteOrRelativeTimeType> earliestStartTime ;
	std::optional<AbsoluteOrRelativeTimeType> latestEndTime ;
	std::optional<duration> minDuration ;
	std::optional<duration> maxDuration ;
	std::optional<boolean> optionalSlot ;
};
struct PowerTimeSlotScheduleConstraintsDataElementsType {
	std::optional<ElementTagType> sequenceId ;
	std::optional<ElementTagType> slotNumber ;
	std::optional<ElementTagType> earliestStartTime ;
	std::optional<ElementTagType> latestEndTime ;
	std::optional<ElementTagType> minDuration ;
	std::optional<ElementTagType> maxDuration ;
	std::optional<ElementTagType> optionalSlot ;
};
struct PowerTimeSlotScheduleConstraintsListDataType {
	std::optional<PowerTimeSlotScheduleConstraintsDataType> powerTimeSlotScheduleConstraintsData ;
};
struct PowerTimeSlotScheduleConstraintsListDataSelectorsType {
	std::optional<PowerSequenceIdType> sequenceId ;
	std::optional<PowerTimeSlotNumberType> slotNumber ;
};
struct PowerSequenceAlternativesRelationDataType {
	std::optional<AlternativesIdType> alternativesId ;
	std::optional<PowerSequenceIdType> sequenceId ;
};
struct PowerSequenceAlternativesRelationDataElementsType {
	std::optional<ElementTagType> alternativesId ;
	std::optional<ElementTagType> sequenceId ;
};
struct PowerSequenceAlternativesRelationListDataType {
	std::optional<PowerSequenceAlternativesRelationDataType> powerSequenceAlternativesRelationData ;
};
struct PowerSequenceAlternativesRelationListDataSelectorsType {
	std::optional<AlternativesIdType> alternativesId ;
	std::optional<PowerSequenceIdType> sequenceId ;
};
struct PowerSequenceDescriptionDataType {
	std::optional<PowerSequenceIdType> sequenceId ;
	std::optional<DescriptionType> description ;
	std::optional<EnergyDirectionType> positiveEnergyDirection ;
	std::optional<UnitOfMeasurementType> powerUnit ;
	std::optional<UnitOfMeasurementType> energyUnit ;
	std::optional<MeasurementValueSourceType> valueSource ;
	std::optional<PowerSequenceScopeType> scope ;
	std::optional<unsignedInt> taskIdentifier ;
	std::optional<unsignedInt> repetitionsTotal ;
};
struct PowerSequenceDescriptionDataElementsType {
	std::optional<ElementTagType> sequenceId ;
	std::optional<ElementTagType> description ;
	std::optional<ElementTagType> positiveEnergyDirection ;
	std::optional<ElementTagType> powerUnit ;
	std::optional<ElementTagType> energyUnit ;
	std::optional<ElementTagType> valueSource ;
	std::optional<ElementTagType> scope ;
	std::optional<ElementTagType> taskIdentifier ;
	std::optional<ElementTagType> repetitionsTotal ;
};
struct PowerSequenceDescriptionListDataType {
	std::optional<PowerSequenceDescriptionDataType> powerSequenceDescriptionData ;
};
struct PowerSequenceDescriptionListDataSelectorsType {
	std::optional<PowerSequenceIdType> sequenceId ;
};
struct PowerSequenceStateDataType {
	std::optional<PowerSequenceIdType> sequenceId ;
	std::optional<PowerSequenceStateType> state ;
	std::optional<PowerTimeSlotNumberType> activeSlotNumber ;
	std::optional<duration> elapsedSlotTime ;
	std::optional<duration> remainingSlotTime ;
	std::optional<boolean> sequenceRemoteControllable ;
	std::optional<unsignedInt> activeRepetitionNumber ;
	std::optional<duration> remainingPauseTime ;
};
struct PowerSequenceStateDataElementsType {
	std::optional<ElementTagType> sequenceId ;
	std::optional<ElementTagType> state ;
	std::optional<ElementTagType> activeSlotNumber ;
	std::optional<ElementTagType> elapsedSlotTime ;
	std::optional<ElementTagType> remainingSlotTime ;
	std::optional<ElementTagType> sequenceRemoteControllable ;
	std::optional<ElementTagType> activeRepetitionNumber ;
	std::optional<ElementTagType> remainingPauseTime ;
};
struct PowerSequenceStateListDataType {
	std::optional<PowerSequenceStateDataType> powerSequenceStateData ;
};
struct PowerSequenceStateListDataSelectorsType {
	std::optional<PowerSequenceIdType> sequenceId ;
};
struct PowerSequenceScheduleDataType {
	std::optional<PowerSequenceIdType> sequenceId ;
	std::optional<AbsoluteOrRelativeTimeType> startTime ;
	std::optional<AbsoluteOrRelativeTimeType> endTime ;
};
struct PowerSequenceScheduleDataElementsType {
	std::optional<ElementTagType> sequenceId ;
	std::optional<ElementTagType> startTime ;
	std::optional<ElementTagType> endTime ;
};
struct PowerSequenceScheduleListDataType {
	std::optional<PowerSequenceScheduleDataType> powerSequenceScheduleData ;
};
struct PowerSequenceScheduleListDataSelectorsType {
	std::optional<PowerSequenceIdType> sequenceId ;
};
struct PowerSequenceScheduleConstraintsDataType {
	std::optional<PowerSequenceIdType> sequenceId ;
	std::optional<AbsoluteOrRelativeTimeType> earliestStartTime ;
	std::optional<AbsoluteOrRelativeTimeType> latestStartTime ;
	std::optional<AbsoluteOrRelativeTimeType> earliestEndTime ;
	std::optional<AbsoluteOrRelativeTimeType> latestEndTime ;
	std::optional<boolean> optionalSequence ;
};
struct PowerSequenceScheduleConstraintsDataElementsType {
	std::optional<ElementTagType> sequenceId ;
	std::optional<ElementTagType> earliestStartTime ;
	std::optional<ElementTagType> latestStartTime ;
	std::optional<ElementTagType> earliestEndTime ;
	std::optional<ElementTagType> latestEndTime ;
	std::optional<ElementTagType> optionalSequence ;
};
struct PowerSequenceScheduleConstraintsListDataType {
	std::optional<PowerSequenceScheduleConstraintsDataType> powerSequenceScheduleConstraintsData ;
};
struct PowerSequenceScheduleConstraintsListDataSelectorsType {
	std::optional<PowerSequenceIdType> sequenceId ;
};
struct PowerSequencePriceDataType {
	std::optional<PowerSequenceIdType> sequenceId ;
	std::optional<AbsoluteOrRelativeTimeType> potentialStartTime ;
	std::optional<ScaledNumberType> price ;
	std::optional<CurrencyType> currency ;
};
struct PowerSequencePriceDataElementsType {
	std::optional<ElementTagType> sequenceId ;
	std::optional<ElementTagType> potentialStartTime ;
	std::optional<ScaledNumberElementsType> price ;
	std::optional<ElementTagType> currency ;
};
struct PowerSequencePriceListDataType {
	std::optional<PowerSequencePriceDataType> powerSequencePriceData ;
};
struct PowerSequencePriceListDataSelectorsType {
	std::optional<PowerSequenceIdType> sequenceId ;
	std::optional<TimestampIntervalType> potentialStartTimeInterval ;
};
struct PowerSequenceSchedulePreferenceDataType {
	std::optional<PowerSequenceIdType> sequenceId ;
	std::optional<boolean> greenest ;
	std::optional<boolean> cheapest ;
};
struct PowerSequenceSchedulePreferenceDataElementsType {
	std::optional<ElementTagType> sequenceId ;
	std::optional<ElementTagType> greenest ;
	std::optional<ElementTagType> cheapest ;
};
struct PowerSequenceSchedulePreferenceListDataType {
	std::optional<PowerSequenceSchedulePreferenceDataType> powerSequenceSchedulePreferenceData ;
};
struct PowerSequenceSchedulePreferenceListDataSelectorsType {
	std::optional<PowerSequenceIdType> sequenceId ;
};
struct PowerSequenceNodeScheduleInformationDataType {
	std::optional<boolean> nodeRemoteControllable ;
	std::optional<boolean> supportsSingleSlotSchedulingOnly ;
	std::optional<unsignedInt> alternativesCount ;
	std::optional<unsignedInt> totalSequencesCountMax ;
	std::optional<boolean> supportsReselection ;
};
struct PowerSequenceNodeScheduleInformationDataElementsType {
	std::optional<ElementTagType> nodeRemoteControllable ;
	std::optional<ElementTagType> supportsSingleSlotSchedulingOnly ;
	std::optional<ElementTagType> alternativesCount ;
	std::optional<ElementTagType> totalSequencesCountMax ;
	std::optional<ElementTagType> supportsReselection ;
};
struct PowerSequenceScheduleConfigurationRequestCallType {
	std::optional<PowerSequenceIdType> sequenceId ;
};
struct PowerSequenceScheduleConfigurationRequestCallElementsType {
	std::optional<ElementTagType> sequenceId ;
};
struct PowerSequencePriceCalculationRequestCallType {
	std::optional<PowerSequenceIdType> sequenceId ;
	std::optional<AbsoluteOrRelativeTimeType> potentialStartTime ;
};
struct PowerSequencePriceCalculationRequestCallElementsType {
	std::optional<ElementTagType> sequenceId ;
	std::optional<ElementTagType> potentialStartTime ;
};
struct ResultDataType {
	std::optional<ErrorNumberType> errorNumber ;
	std::optional<DescriptionType> description ;
};
struct BindingManagementEntryDataType {
	std::optional<BindingIdType> bindingId ;
	std::optional<FeatureAddressType> clientAddress ;
	std::optional<FeatureAddressType> serverAddress ;
	std::optional<LabelType> label ;
	std::optional<DescriptionType> description ;
};
struct BindingManagementEntryDataElementsType {
	std::optional<ElementTagType> bindingId ;
	std::optional<FeatureAddressElementsType> clientAddress ;
	std::optional<FeatureAddressElementsType> serverAddress ;
	std::optional<ElementTagType> label ;
	std::optional<ElementTagType> description ;
};
struct BindingManagementEntryListDataType {
	std::optional<BindingManagementEntryDataType> bindingManagementEntryData ;
};
struct BindingManagementEntryListDataSelectorsType {
	std::optional<BindingIdType> bindingId ;
	std::optional<FeatureAddressType> clientAddress ;
	std::optional<FeatureAddressType> serverAddress ;
};
struct BindingManagementRequestCallType {
	std::optional<FeatureAddressType> clientAddress ;
	std::optional<FeatureAddressType> serverAddress ;
	std::optional<FeatureTypeType> serverFeatureType ;
};
struct BindingManagementRequestCallElementsType {
	std::optional<FeatureAddressElementsType> clientAddress ;
	std::optional<FeatureAddressElementsType> serverAddress ;
	std::optional<ElementTagType> serverFeatureType ;
};
struct BindingManagementDeleteCallType {
	std::optional<BindingIdType> bindingId ;
	std::optional<FeatureAddressType> clientAddress ;
	std::optional<FeatureAddressType> serverAddress ;
};
struct BindingManagementDeleteCallElementsType {
	std::optional<ElementTagType> bindingId ;
	std::optional<FeatureAddressElementsType> clientAddress ;
	std::optional<FeatureAddressElementsType> serverAddress ;
};
struct ActuatorLevelFctType {
	std::optional<ActuatorLevelFctEnumType> actuatorlevelfctenumtype;
	std::optional<EnumExtendType> enumextendtype;
};
struct ActuatorLevelDataType {
	std::optional<ActuatorLevelFctType> function ;
	std::optional<ScaledNumberType> value ;
};
struct ActuatorLevelDataElementsType {
	std::optional<ElementTagType> function ;
	std::optional<ScaledNumberElementsType> value ;
};
struct ActuatorLevelDescriptionDataType {
	std::optional<LabelType> label ;
	std::optional<DescriptionType> description ;
	std::optional<UnitOfMeasurementType> levelDefaultUnit ;
};
struct ActuatorLevelDescriptionDataElementsType {
	std::optional<ElementTagType> label ;
	std::optional<ElementTagType> description ;
	std::optional<ElementTagType> levelDefaultUnit ;
};
struct ActuatorSwitchFctType {
	std::optional<ActuatorSwitchFctEnumType> actuatorswitchfctenumtype;
	std::optional<EnumExtendType> enumextendtype;
};
struct AlarmTypeType {
	std::optional<AlarmTypeEnumType> alarmtypeenumtype;
	std::optional<EnumExtendType> enumextendtype;
};
struct BillTypeType {
	std::optional<BillTypeEnumType> billtypeenumtype;
	std::optional<EnumExtendType> enumextendtype;
};
struct BillPositionTypeType {
	std::optional<BillPositionTypeEnumType> billpositiontypeenumtype;
	std::optional<EnumExtendType> enumextendtype;
};
struct BillCostTypeType {
	std::optional<BillCostTypeEnumType> billcosttypeenumtype;
	std::optional<EnumExtendType> enumextendtype;
};
struct IdentificationTypeType {
	std::optional<IdentificationTypeEnumType> identificationtypeenumtype;
	std::optional<EnumExtendType> enumextendtype;
};
struct PowerSourceType {
	std::optional<PowerSourceEnumType> powersourceenumtype;
	std::optional<EnumExtendType> enumextendtype;
};
struct DeviceConfigurationKeyNameType {
	std::optional<DeviceConfigurationKeyNameEnumType> deviceconfigurationkeynameenumtype;
	std::optional<EnumExtendType> enumextendtype;
};
struct DeviceDiagnosisOperatingStateType {
	std::optional<DeviceDiagnosisOperatingStateEnumType> devicediagnosisoperatingstateenumtype;
	std::optional<EnumExtendType> enumextendtype;
};
struct PowerSupplyConditionType {
	std::optional<PowerSupplyConditionEnumType> powersupplyconditionenumtype;
	std::optional<EnumExtendType> enumextendtype;
};
struct ElectricalConnectionMeasurandVariantType {
	std::optional<ElectricalConnectionMeasurandVariantEnumType> electricalconnectionmeasurandvariantenumtype;
	std::optional<EnumExtendType> enumextendtype;
};
struct ElectricalConnectionVoltageTypeType {
	std::optional<ElectricalConnectionVoltageTypeEnumType> electricalconnectionvoltagetypeenumtype;
	std::optional<EnumExtendType> enumextendtype;
};
struct ElectricalConnectionAcMeasurementTypeType {
	std::optional<ElectricalConnectionAcMeasurementTypeEnumType> electricalconnectionacmeasurementtypeenumtype;
	std::optional<EnumExtendType> enumextendtype;
};
struct ElectricalConnectionPhaseNameType {
	std::optional<ElectricalConnectionPhaseNameEnumType> electricalconnectionphasenameenumtype;
	std::optional<EnumExtendType> enumextendtype;
};
struct ElectricalConnectionCharacteristicContextType {
	std::optional<ElectricalConnectionCharacteristicContextEnumType> electricalconnectioncharacteristiccontextenumtype;
	std::optional<EnumExtendType> enumextendtype;
};
struct ElectricalConnectionCharacteristicTypeType {
	std::optional<ElectricalConnectionCharacteristicTypeEnumType> electricalconnectioncharacteristictypeenumtype;
	std::optional<EnumExtendType> enumextendtype;
};
struct HvacSystemFunctionTypeType {
	std::optional<HvacSystemFunctionTypeEnumType> hvacsystemfunctiontypeenumtype;
	std::optional<EnumExtendType> enumextendtype;
};
struct HvacOperationModeTypeType {
	std::optional<HvacOperationModeTypeEnumType> hvacoperationmodetypeenumtype;
	std::optional<EnumExtendType> enumextendtype;
};
struct HvacOverrunTypeType {
	std::optional<HvacOverrunTypeEnumType> hvacoverruntypeenumtype;
	std::optional<EnumExtendType> enumextendtype;
};
struct HvacOverrunStatusType {
	std::optional<HvacOverrunStatusEnumType> hvacoverrunstatusenumtype;
	std::optional<EnumExtendType> enumextendtype;
};
struct SetpointTypeType {
	std::optional<SetpointTypeEnumType> setpointtypeenumtype;
	std::optional<EnumExtendType> enumextendtype;
};
struct TimeSlotTimeModeType {
	std::optional<TimeSlotTimeModeEnumType> timeslottimemodeenumtype;
	std::optional<EnumExtendType> enumextendtype;
};
struct TierBoundaryTypeType {
	std::optional<TierBoundaryTypeEnumType> tierboundarytypeenumtype;
	std::optional<EnumExtendType> enumextendtype;
};
struct TierTypeType {
	std::optional<TierTypeEnumType> tiertypeenumtype;
	std::optional<EnumExtendType> enumextendtype;
};
struct IncentiveTypeType {
	std::optional<IncentiveTypeEnumType> incentivetypeenumtype;
	std::optional<EnumExtendType> enumextendtype;
};
struct IncentiveValueTypeType {
	std::optional<IncentiveValueTypeEnumType> incentivevaluetypeenumtype;
	std::optional<EnumExtendType> enumextendtype;
};
struct LoadControlEventActionType {
	std::optional<LoadControlEventActionEnumType> loadcontroleventactionenumtype;
	std::optional<EnumExtendType> enumextendtype;
};
struct LoadControlEventStateType {
	std::optional<LoadControlEventStateEnumType> loadcontroleventstateenumtype;
	std::optional<EnumExtendType> enumextendtype;
};
struct LoadControlLimitTypeType {
	std::optional<LoadControlLimitTypeEnumType> loadcontrollimittypeenumtype;
	std::optional<EnumExtendType> enumextendtype;
};
struct LoadControlCategoryType {
	std::optional<LoadControlCategoryEnumType> loadcontrolcategoryenumtype;
	std::optional<EnumExtendType> enumextendtype;
};
struct UseCaseActorType {
	std::optional<UseCaseActorEnumType> usecaseactorenumtype;
	std::optional<EnumExtendType> enumextendtype;
};
struct UseCaseNameType {
	std::optional<UseCaseNameEnumType> usecasenameenumtype;
	std::optional<EnumExtendType> enumextendtype;
};
struct SensingStateType {
	std::optional<SensingStateEnumType> sensingstateenumtype;
	std::optional<EnumExtendType> enumextendtype;
};
struct SensingTypeType {
	std::optional<SensingTypeEnumType> sensingtypeenumtype;
	std::optional<EnumExtendType> enumextendtype;
};
struct StateInformationType {
	std::optional<StateInformationFunctionalityEnumType> stateinformationfunctionalityenumtype;
	std::optional<StateInformationFailureEnumType> stateinformationfailureenumtype;
	std::optional<EnumExtendType> enumextendtype;
};
struct StateInformationCategoryType {
	std::optional<StateInformationCategoryEnumType> stateinformationcategoryenumtype;
	std::optional<EnumExtendType> enumextendtype;
};
struct SupplyConditionEventTypeType {
	std::optional<SupplyConditionEventTypeEnumType> supplyconditioneventtypeenumtype;
	std::optional<EnumExtendType> enumextendtype;
};
struct SupplyConditionOriginatorType {
	std::optional<SupplyConditionOriginatorEnumType> supplyconditionoriginatorenumtype;
	std::optional<EnumExtendType> enumextendtype;
};
struct GridConditionType {
	std::optional<GridConditionEnumType> gridconditionenumtype;
	std::optional<EnumExtendType> enumextendtype;
};
struct TaskManagementJobStateType {
	std::optional<DirectControlActivityStateEnumType> directcontrolactivitystateenumtype;
	std::optional<HvacOverrunStatusEnumType> hvacoverrunstatusenumtype;
	std::optional<LoadControlEventStateEnumType> loadcontroleventstateenumtype;
	std::optional<PowerSequenceStateEnumType> powersequencestateenumtype;
	std::optional<EnumExtendType> enumextendtype;
};
struct TaskManagementJobSourceType {
	std::optional<TaskManagementJobSourceEnumType> taskmanagementjobsourceenumtype;
	std::optional<EnumExtendType> enumextendtype;
};
struct CmdControlType {
	std::optional<ElementTagType> delete ;
	std::optional<ElementTagType> partial ;
};
struct CmdType {
	std::optional<PayloadContributionGroup> PayloadContributionGroup ;
};
struct ActuatorSwitchDataType {
	std::optional<ActuatorSwitchFctType> function ;
};
struct ActuatorSwitchDataElementsType {
	std::optional<ElementTagType> function ;
};
struct ActuatorSwitchDescriptionDataType {
	std::optional<LabelType> label ;
	std::optional<DescriptionType> description ;
};
struct ActuatorSwitchDescriptionDataElementsType {
	std::optional<ElementTagType> label ;
	std::optional<ElementTagType> description ;
};
struct AlarmDataType {
	std::optional<AlarmIdType> alarmId ;
	std::optional<ThresholdIdType> thresholdId ;
	std::optional<AbsoluteOrRelativeTimeType> timestamp ;
	std::optional<AlarmTypeType> alarmType ;
	std::optional<ScaledNumberType> measuredValue ;
	std::optional<TimePeriodType> evaluationPeriod ;
	std::optional<ScopeTypeType> scopeType ;
	std::optional<LabelType> label ;
	std::optional<DescriptionType> description ;
};
struct AlarmDataElementsType {
	std::optional<ElementTagType> alarmId ;
	std::optional<ElementTagType> thresholdId ;
	std::optional<ElementTagType> timestamp ;
	std::optional<ElementTagType> alarmType ;
	std::optional<ScaledNumberElementsType> measuredValue ;
	std::optional<TimePeriodElementsType> evaluationPeriod ;
	std::optional<ElementTagType> scopeType ;
	std::optional<ElementTagType> label ;
	std::optional<ElementTagType> description ;
};
struct AlarmListDataType {
	std::optional<AlarmDataType> alarmData ;
};
struct AlarmListDataSelectorsType {
	std::optional<AlarmIdType> alarmId ;
	std::optional<ScopeTypeType> scopeType ;
};
struct BillValueType {
	std::optional<BillValueIdType> valueId ;
	std::optional<UnitOfMeasurementType> unit ;
	std::optional<ScaledNumberType> value ;
	std::optional<ScaledNumberType> valuePercentage ;
};
struct BillValueElementsType {
	std::optional<ElementTagType> valueId ;
	std::optional<ElementTagType> unit ;
	std::optional<ScaledNumberElementsType> value ;
	std::optional<ScaledNumberElementsType> valuePercentage ;
};
struct BillCostType {
	std::optional<BillCostIdType> costId ;
	std::optional<BillCostTypeType> costType ;
	std::optional<BillValueIdType> valueId ;
	std::optional<UnitOfMeasurementType> unit ;
	std::optional<CurrencyType> currency ;
	std::optional<ScaledNumberType> cost ;
	std::optional<ScaledNumberType> costPercentage ;
};
struct BillCostElementsType {
	std::optional<ElementTagType> costId ;
	std::optional<ElementTagType> costType ;
	std::optional<ElementTagType> valueId ;
	std::optional<ElementTagType> unit ;
	std::optional<ElementTagType> currency ;
	std::optional<ScaledNumberElementsType> cost ;
	std::optional<ScaledNumberElementsType> costPercentage ;
};
struct BillPositionType {
	std::optional<BillPositionIdType> positionId ;
	std::optional<BillPositionTypeType> positionType ;
	std::optional<TimePeriodType> timePeriod ;
	std::optional<BillValueType> value ;
	std::optional<BillCostType> cost ;
	std::optional<LabelType> label ;
	std::optional<DescriptionType> description ;
};
struct BillPositionElementsType {
	std::optional<ElementTagType> positionId ;
	std::optional<ElementTagType> positionType ;
	std::optional<TimePeriodElementsType> timePeriod ;
	std::optional<BillValueElementsType> value ;
	std::optional<BillCostElementsType> cost ;
	std::optional<ElementTagType> label ;
	std::optional<ElementTagType> description ;
};
struct BillDataType {
	std::optional<BillIdType> billId ;
	std::optional<BillTypeType> billType ;
	std::optional<ScopeTypeType> scopeType ;
	std::optional<None> total ;
	std::optional<None> position ;
};
struct BillDataElementsType {
	std::optional<ElementTagType> billId ;
	std::optional<ElementTagType> billType ;
	std::optional<ElementTagType> scopeType ;
	std::optional<None> total ;
	std::optional<None> position ;
};
struct BillListDataType {
	std::optional<BillDataType> billData ;
};
struct BillListDataSelectorsType {
	std::optional<BillIdType> billId ;
	std::optional<ScopeTypeType> scopeType ;
};
struct BillConstraintsDataType {
	std::optional<BillIdType> billId ;
	std::optional<BillPositionCountType> positionCountMin ;
	std::optional<BillPositionCountType> positionCountMax ;
};
struct BillConstraintsDataElementsType {
	std::optional<ElementTagType> billId ;
	std::optional<ElementTagType> positionCountMin ;
	std::optional<ElementTagType> positionCountMax ;
};
struct BillConstraintsListDataType {
	std::optional<BillConstraintsDataType> billConstraintsData ;
};
struct BillConstraintsListDataSelectorsType {
	std::optional<BillIdType> billId ;
};
struct BillDescriptionDataType {
	std::optional<BillIdType> billId ;
	std::optional<boolean> billWriteable ;
	std::optional<boolean> updateRequired ;
	std::optional<BillTypeType> supportedBillType ;
	std::optional<SessionIdType> sessionId ;
};
struct BillDescriptionDataElementsType {
	std::optional<ElementTagType> billId ;
	std::optional<ElementTagType> billWriteable ;
	std::optional<ElementTagType> updateRequired ;
	std::optional<ElementTagType> supportedBillType ;
	std::optional<ElementTagType> sessionId ;
};
struct BillDescriptionListDataType {
	std::optional<BillDescriptionDataType> billDescriptionData ;
};
struct BillDescriptionListDataSelectorsType {
	std::optional<BillIdType> billId ;
};
struct IdentificationDataType {
	std::optional<IdentificationIdType> identificationId ;
	std::optional<IdentificationTypeType> identificationType ;
	std::optional<IdentificationValueType> identificationValue ;
	std::optional<boolean> authorized ;
};
struct IdentificationDataElementsType {
	std::optional<ElementTagType> identificationId ;
	std::optional<ElementTagType> identificationType ;
	std::optional<ElementTagType> identificationValue ;
	std::optional<ElementTagType> authorized ;
};
struct IdentificationListDataType {
	std::optional<IdentificationDataType> identificationData ;
};
struct IdentificationListDataSelectorsType {
	std::optional<IdentificationIdType> identificationId ;
	std::optional<IdentificationTypeType> identificationType ;
};
struct SessionIdentificationDataType {
	std::optional<SessionIdType> sessionId ;
	std::optional<IdentificationIdType> identificationId ;
	std::optional<boolean> isLatestSession ;
	std::optional<TimePeriodType> timePeriod ;
};
struct SessionIdentificationDataElementsType {
	std::optional<ElementTagType> sessionId ;
	std::optional<ElementTagType> identificationId ;
	std::optional<ElementTagType> isLatestSession ;
	std::optional<TimePeriodElementsType> timePeriod ;
};
struct SessionIdentificationListDataType {
	std::optional<SessionIdentificationDataType> sessionIdentificationData ;
};
struct SessionIdentificationListDataSelectorsType {
	std::optional<SessionIdType> sessionId ;
	std::optional<IdentificationIdType> identificationId ;
	std::optional<boolean> isLatestSession ;
	std::optional<TimePeriodType> timePeriod ;
};
struct SessionMeasurementRelationDataType {
	std::optional<SessionIdType> sessionId ;
	std::optional<MeasurementIdType> measurementId ;
};
struct SessionMeasurementRelationDataElementsType {
	std::optional<ElementTagType> sessionId ;
	std::optional<ElementTagType> measurementId ;
};
struct SessionMeasurementRelationListDataType {
	std::optional<SessionMeasurementRelationDataType> sessionMeasurementRelationData ;
};
struct SessionMeasurementRelationListDataSelectorsType {
	std::optional<SessionIdType> sessionId ;
	std::optional<MeasurementIdType> measurementId ;
};
struct DataTunnelingHeaderType {
	std::optional<PurposeIdType> purposeId ;
	std::optional<ChannelIdType> channelId ;
	std::optional<unsignedInt> sequenceId ;
};
struct DataTunnelingHeaderElementsType {
	std::optional<ElementTagType> purposeId ;
	std::optional<ElementTagType> channelId ;
	std::optional<ElementTagType> sequenceId ;
};
struct DataTunnelingCallType {
	std::optional<DataTunnelingHeaderType> header ;
	std::optional<hexBinary> payload ;
};
struct DataTunnelingCallElementsType {
	std::optional<DataTunnelingHeaderElementsType> header ;
	std::optional<ElementTagType> payload ;
};
struct DeviceClassificationManufacturerDataType {
	std::optional<DeviceClassificationStringType> deviceName ;
	std::optional<DeviceClassificationStringType> deviceCode ;
	std::optional<DeviceClassificationStringType> serialNumber ;
	std::optional<DeviceClassificationStringType> softwareRevision ;
	std::optional<DeviceClassificationStringType> hardwareRevision ;
	std::optional<DeviceClassificationStringType> vendorName ;
	std::optional<DeviceClassificationStringType> vendorCode ;
	std::optional<DeviceClassificationStringType> brandName ;
	std::optional<PowerSourceType> powerSource ;
	std::optional<DeviceClassificationStringType> manufacturerNodeIdentification ;
	std::optional<LabelType> manufacturerLabel ;
	std::optional<DescriptionType> manufacturerDescription ;
};
struct DeviceClassificationManufacturerDataElementsType {
	std::optional<ElementTagType> deviceName ;
	std::optional<ElementTagType> deviceCode ;
	std::optional<ElementTagType> serialNumber ;
	std::optional<ElementTagType> softwareRevision ;
	std::optional<ElementTagType> hardwareRevision ;
	std::optional<ElementTagType> vendorName ;
	std::optional<ElementTagType> vendorCode ;
	std::optional<ElementTagType> brandName ;
	std::optional<ElementTagType> powerSource ;
	std::optional<ElementTagType> manufacturerNodeIdentification ;
	std::optional<ElementTagType> manufacturerLabel ;
	std::optional<ElementTagType> manufacturerDescription ;
};
struct DeviceClassificationUserDataType {
	std::optional<DeviceClassificationStringType> userNodeIdentification ;
	std::optional<LabelType> userLabel ;
	std::optional<DescriptionType> userDescription ;
};
struct DeviceClassificationUserDataElementsType {
	std::optional<ElementTagType> userNodeIdentification ;
	std::optional<ElementTagType> userLabel ;
	std::optional<ElementTagType> userDescription ;
};
struct DeviceConfigurationKeyValueValueType {
	std::optional<boolean> boolean ;
	std::optional<date> date ;
	std::optional<dateTime> dateTime ;
	std::optional<duration> duration ;
	std::optional<DeviceConfigurationKeyValueStringType> string ;
	std::optional<time> time ;
	std::optional<ScaledNumberType> scaledNumber ;
	std::optional<long> integer ;
};
struct DeviceConfigurationKeyValueValueElementsType {
	std::optional<ElementTagType> boolean ;
	std::optional<ElementTagType> date ;
	std::optional<ElementTagType> dateTime ;
	std::optional<ElementTagType> duration ;
	std::optional<ElementTagType> string ;
	std::optional<ElementTagType> time ;
	std::optional<ScaledNumberElementsType> scaledNumber ;
};
struct DeviceConfigurationKeyValueDataType {
	std::optional<DeviceConfigurationKeyIdType> keyId ;
	std::optional<DeviceConfigurationKeyValueValueType> value ;
	std::optional<boolean> isValueChangeable ;
};
struct DeviceConfigurationKeyValueDataElementsType {
	std::optional<ElementTagType> keyId ;
	std::optional<DeviceConfigurationKeyValueValueElementsType> value ;
	std::optional<ElementTagType> isValueChangeable ;
};
struct DeviceConfigurationKeyValueListDataType {
	std::optional<DeviceConfigurationKeyValueDataType> deviceConfigurationKeyValueData ;
};
struct DeviceConfigurationKeyValueListDataSelectorsType {
	std::optional<DeviceConfigurationKeyIdType> keyId ;
};
struct DeviceConfigurationKeyValueDescriptionDataType {
	std::optional<DeviceConfigurationKeyIdType> keyId ;
	std::optional<DeviceConfigurationKeyNameType> keyName ;
	std::optional<DeviceConfigurationKeyValueTypeType> valueType ;
	std::optional<UnitOfMeasurementType> unit ;
	std::optional<LabelType> label ;
	std::optional<DescriptionType> description ;
};
struct DeviceConfigurationKeyValueDescriptionDataElementsType {
	std::optional<ElementTagType> keyId ;
	std::optional<ElementTagType> keyName ;
	std::optional<ElementTagType> valueType ;
	std::optional<ElementTagType> unit ;
	std::optional<ElementTagType> label ;
	std::optional<ElementTagType> description ;
};
struct DeviceConfigurationKeyValueDescriptionListDataType {
	std::optional<DeviceConfigurationKeyValueDescriptionDataType> deviceConfigurationKeyValueDescriptionData ;
};
struct DeviceConfigurationKeyValueDescriptionListDataSelectorsType {
	std::optional<DeviceConfigurationKeyIdType> keyId ;
	std::optional<DeviceConfigurationKeyNameType> keyName ;
};
struct DeviceConfigurationKeyValueConstraintsDataType {
	std::optional<DeviceConfigurationKeyIdType> keyId ;
	std::optional<DeviceConfigurationKeyValueValueType> valueRangeMin ;
	std::optional<DeviceConfigurationKeyValueValueType> valueRangeMax ;
	std::optional<DeviceConfigurationKeyValueValueType> valueStepSize ;
};
struct DeviceConfigurationKeyValueConstraintsDataElementsType {
	std::optional<ElementTagType> keyId ;
	std::optional<DeviceConfigurationKeyValueValueElementsType> valueRangeMin ;
	std::optional<DeviceConfigurationKeyValueValueElementsType> valueRangeMax ;
	std::optional<DeviceConfigurationKeyValueValueElementsType> valueStepSize ;
};
struct DeviceConfigurationKeyValueConstraintsListDataType {
	std::optional<DeviceConfigurationKeyValueConstraintsDataType> deviceConfigurationKeyValueConstraintsData ;
};
struct DeviceConfigurationKeyValueConstraintsListDataSelectorsType {
	std::optional<DeviceConfigurationKeyIdType> keyId ;
};
struct DeviceDiagnosisStateDataType {
	std::optional<AbsoluteOrRelativeTimeType> timestamp ;
	std::optional<DeviceDiagnosisOperatingStateType> operatingState ;
	std::optional<VendorStateCodeType> vendorStateCode ;
	std::optional<LastErrorCodeType> lastErrorCode ;
	std::optional<duration> upTime ;
	std::optional<duration> totalUpTime ;
	std::optional<PowerSupplyConditionType> powerSupplyCondition ;
};
struct DeviceDiagnosisStateDataElementsType {
	std::optional<ElementTagType> timestamp ;
	std::optional<ElementTagType> operatingState ;
	std::optional<ElementTagType> vendorStateCode ;
	std::optional<ElementTagType> lastErrorCode ;
	std::optional<ElementTagType> upTime ;
	std::optional<ElementTagType> totalUpTime ;
	std::optional<ElementTagType> powerSupplyCondition ;
};
struct DeviceDiagnosisHeartbeatDataType {
	std::optional<AbsoluteOrRelativeTimeType> timestamp ;
	std::optional<unsignedLong> heartbeatCounter ;
	std::optional<duration> heartbeatTimeout ;
};
struct DeviceDiagnosisHeartbeatDataElementsType {
	std::optional<ElementTagType> timestamp ;
	std::optional<ElementTagType> heartbeatCounter ;
	std::optional<ElementTagType> heartbeatTimeout ;
};
struct DeviceDiagnosisServiceDataType {
	std::optional<AbsoluteOrRelativeTimeType> timestamp ;
	std::optional<AbsoluteOrRelativeTimeType> installationTime ;
	std::optional<unsignedLong> bootCounter ;
	std::optional<AbsoluteOrRelativeTimeType> nextService ;
};
struct DeviceDiagnosisServiceDataElementsType {
	std::optional<ElementTagType> timestamp ;
	std::optional<ElementTagType> installationTime ;
	std::optional<ElementTagType> bootCounter ;
	std::optional<ElementTagType> nextService ;
};
struct ElectricalConnectionParameterDescriptionDataType {
	std::optional<ElectricalConnectionIdType> electricalConnectionId ;
	std::optional<ElectricalConnectionParameterIdType> parameterId ;
	std::optional<MeasurementIdType> measurementId ;
	std::optional<ElectricalConnectionVoltageTypeType> voltageType ;
	std::optional<ElectricalConnectionPhaseNameType> acMeasuredPhases ;
	std::optional<ElectricalConnectionPhaseNameType> acMeasuredInReferenceTo ;
	std::optional<ElectricalConnectionAcMeasurementTypeType> acMeasurementType ;
	std::optional<ElectricalConnectionMeasurandVariantType> acMeasurementVariant ;
	std::optional<unsignedByte> acMeasuredHarmonic ;
	std::optional<ScopeTypeType> scopeType ;
	std::optional<LabelType> label ;
	std::optional<DescriptionType> description ;
};
struct ElectricalConnectionParameterDescriptionDataElementsType {
	std::optional<ElementTagType> electricalConnectionId ;
	std::optional<ElementTagType> parameterId ;
	std::optional<ElementTagType> measurementId ;
	std::optional<ElementTagType> voltageType ;
	std::optional<ElementTagType> acMeasuredPhases ;
	std::optional<ElementTagType> acMeasuredInReferenceTo ;
	std::optional<ElementTagType> acMeasurementType ;
	std::optional<ElementTagType> acMeasurementVariant ;
	std::optional<ElementTagType> acMeasuredHarmonic ;
	std::optional<ElementTagType> scopeType ;
	std::optional<ElementTagType> label ;
	std::optional<ElementTagType> description ;
};
struct ElectricalConnectionParameterDescriptionListDataType {
	std::optional<ElectricalConnectionParameterDescriptionDataType> electricalConnectionParameterDescriptionData ;
};
struct ElectricalConnectionParameterDescriptionListDataSelectorsType {
	std::optional<ElectricalConnectionIdType> electricalConnectionId ;
	std::optional<ElectricalConnectionParameterIdType> parameterId ;
	std::optional<MeasurementIdType> measurementId ;
	std::optional<ScopeTypeType> scopeType ;
};
struct ElectricalConnectionPermittedValueSetDataType {
	std::optional<ElectricalConnectionIdType> electricalConnectionId ;
	std::optional<ElectricalConnectionParameterIdType> parameterId ;
	std::optional<ScaledNumberSetType> permittedValueSet ;
};
struct ElectricalConnectionPermittedValueSetDataElementsType {
	std::optional<ElementTagType> electricalConnectionId ;
	std::optional<ElementTagType> parameterId ;
	std::optional<ScaledNumberSetElementsType> permittedValueSet ;
};
struct ElectricalConnectionPermittedValueSetListDataType {
	std::optional<ElectricalConnectionPermittedValueSetDataType> electricalConnectionPermittedValueSetData ;
};
struct ElectricalConnectionPermittedValueSetListDataSelectorsType {
	std::optional<ElectricalConnectionIdType> electricalConnectionId ;
	std::optional<ElectricalConnectionParameterIdType> parameterId ;
};
struct ElectricalConnectionCharacteristicDataType {
	std::optional<ElectricalConnectionIdType> electricalConnectionId ;
	std::optional<ElectricalConnectionParameterIdType> parameterId ;
	std::optional<ElectricalConnectionCharacteristicIdType> characteristicId ;
	std::optional<ElectricalConnectionCharacteristicContextType> characteristicContext ;
	std::optional<ElectricalConnectionCharacteristicTypeType> characteristicType ;
	std::optional<ScaledNumberType> value ;
	std::optional<UnitOfMeasurementType> unit ;
};
struct ElectricalConnectionCharacteristicDataElementsType {
	std::optional<ElementTagType> electricalConnectionId ;
	std::optional<ElementTagType> parameterId ;
	std::optional<ElementTagType> characteristicId ;
	std::optional<ElementTagType> characteristicContext ;
	std::optional<ElementTagType> characteristicType ;
	std::optional<ScaledNumberElementsType> value ;
	std::optional<ElementTagType> unit ;
};
struct ElectricalConnectionCharacteristicListDataType {
	std::optional<ElectricalConnectionCharacteristicDataType> electricalConnectionCharacteristicData ;
};
struct ElectricalConnectionCharacteristicListDataSelectorsType {
	std::optional<ElectricalConnectionIdType> electricalConnectionId ;
	std::optional<ElectricalConnectionParameterIdType> parameterId ;
	std::optional<ElectricalConnectionCharacteristicIdType> characteristicId ;
	std::optional<ElectricalConnectionCharacteristicContextType> characteristicContext ;
	std::optional<ElectricalConnectionCharacteristicTypeType> characteristicType ;
};
struct ElectricalConnectionStateDataType {
	std::optional<ElectricalConnectionIdType> electricalConnectionId ;
	std::optional<AbsoluteOrRelativeTimeType> timestamp ;
	std::optional<EnergyModeType> currentEnergyMode ;
	std::optional<duration> consumptionTime ;
	std::optional<duration> productionTime ;
	std::optional<duration> totalConsumptionTime ;
	std::optional<duration> totalProductionTime ;
};
struct ElectricalConnectionStateDataElementsType {
	std::optional<ElementTagType> electricalConnectionId ;
	std::optional<ElementTagType> timestamp ;
	std::optional<ElementTagType> currentEnergyMode ;
	std::optional<ElementTagType> consumptionTime ;
	std::optional<ElementTagType> productionTime ;
	std::optional<ElementTagType> totalConsumptionTime ;
	std::optional<ElementTagType> totalProductionTime ;
};
struct ElectricalConnectionStateListDataType {
	std::optional<ElectricalConnectionStateDataType> electricalConnectionStateData ;
};
struct ElectricalConnectionStateListDataSelectorsType {
	std::optional<ElectricalConnectionIdType> electricalConnectionId ;
};
struct ElectricalConnectionDescriptionDataType {
	std::optional<ElectricalConnectionIdType> electricalConnectionId ;
	std::optional<ElectricalConnectionVoltageTypeType> powerSupplyType ;
	std::optional<unsignedInt> acConnectedPhases ;
	std::optional<duration> acRmsPeriodDuration ;
	std::optional<EnergyDirectionType> positiveEnergyDirection ;
	std::optional<ScopeTypeType> scopeType ;
	std::optional<LabelType> label ;
	std::optional<DescriptionType> description ;
};
struct ElectricalConnectionDescriptionDataElementsType {
	std::optional<ElementTagType> electricalConnectionId ;
	std::optional<ElementTagType> powerSupplyType ;
	std::optional<ElementTagType> acConnectedPhases ;
	std::optional<ElementTagType> acRmsPeriodDuration ;
	std::optional<ElementTagType> positiveEnergyDirection ;
	std::optional<ElementTagType> scopeType ;
	std::optional<ElementTagType> label ;
	std::optional<ElementTagType> description ;
};
struct ElectricalConnectionDescriptionListDataType {
	std::optional<ElectricalConnectionDescriptionDataType> electricalConnectionDescriptionData ;
};
struct ElectricalConnectionDescriptionListDataSelectorsType {
	std::optional<ElectricalConnectionIdType> electricalConnectionId ;
	std::optional<ScopeTypeType> scopeType ;
};
struct HvacSystemFunctionDataType {
	std::optional<HvacSystemFunctionIdType> systemFunctionId ;
	std::optional<HvacOperationModeIdType> currentOperationModeId ;
	std::optional<boolean> isOperationModeIdChangeable ;
	std::optional<SetpointIdType> currentSetpointId ;
	std::optional<boolean> isSetpointIdChangeable ;
	std::optional<boolean> isOverrunActive ;
};
struct HvacSystemFunctionDataElementsType {
	std::optional<ElementTagType> systemFunctionId ;
	std::optional<ElementTagType> currentOperationModeId ;
	std::optional<ElementTagType> isOperationModeIdChangeable ;
	std::optional<ElementTagType> currentSetpointId ;
	std::optional<ElementTagType> isSetpointIdChangeable ;
	std::optional<ElementTagType> isOverrunActive ;
};
struct HvacSystemFunctionListDataType {
	std::optional<HvacSystemFunctionDataType> hvacSystemFunctionData ;
};
struct HvacSystemFunctionListDataSelectorsType {
	std::optional<HvacSystemFunctionIdType> systemFunctionId ;
};
struct HvacSystemFunctionOperationModeRelationDataType {
	std::optional<HvacSystemFunctionIdType> systemFunctionId ;
	std::optional<HvacOperationModeIdType> operationModeId ;
};
struct HvacSystemFunctionOperationModeRelationDataElementsType {
	std::optional<ElementTagType> systemFunctionId ;
	std::optional<ElementTagType> operationModeId ;
};
struct HvacSystemFunctionOperationModeRelationListDataType {
	std::optional<HvacSystemFunctionOperationModeRelationDataType> hvacSystemFunctionOperationModeRelationData ;
};
struct HvacSystemFunctionOperationModeRelationListDataSelectorsType {
	std::optional<HvacSystemFunctionIdType> systemFunctionId ;
};
struct HvacSystemFunctionSetpointRelationDataType {
	std::optional<HvacSystemFunctionIdType> systemFunctionId ;
	std::optional<HvacOperationModeIdType> operationModeId ;
	std::optional<SetpointIdType> setpointId ;
};
struct HvacSystemFunctionSetpointRelationDataElementsType {
	std::optional<ElementTagType> systemFunctionId ;
	std::optional<ElementTagType> operationModeId ;
	std::optional<ElementTagType> setpointId ;
};
struct HvacSystemFunctionSetpointRelationListDataType {
	std::optional<HvacSystemFunctionSetpointRelationDataType> hvacSystemFunctionSetpointRelationData ;
};
struct HvacSystemFunctionSetpointRelationListDataSelectorsType {
	std::optional<HvacSystemFunctionIdType> systemFunctionId ;
	std::optional<HvacOperationModeIdType> operationModeId ;
};
struct HvacSystemFunctionPowerSequenceRelationDataType {
	std::optional<HvacSystemFunctionIdType> systemFunctionId ;
	std::optional<PowerSequenceIdType> sequenceId ;
};
struct HvacSystemFunctionPowerSequenceRelationDataElementsType {
	std::optional<ElementTagType> systemFunctionId ;
	std::optional<ElementTagType> sequenceId ;
};
struct HvacSystemFunctionPowerSequenceRelationListDataType {
	std::optional<HvacSystemFunctionPowerSequenceRelationDataType> hvacSystemFunctionPowerSequenceRelationData ;
};
struct HvacSystemFunctionPowerSequenceRelationListDataSelectorsType {
	std::optional<HvacSystemFunctionIdType> systemFunctionId ;
};
struct HvacSystemFunctionDescriptionDataType {
	std::optional<HvacSystemFunctionIdType> systemFunctionId ;
	std::optional<HvacSystemFunctionTypeType> systemFunctionType ;
	std::optional<LabelType> label ;
	std::optional<DescriptionType> description ;
};
struct HvacSystemFunctionDescriptionDataElementsType {
	std::optional<ElementTagType> systemFunctionId ;
	std::optional<ElementTagType> systemFunctionType ;
	std::optional<ElementTagType> label ;
	std::optional<ElementTagType> description ;
};
struct HvacSystemFunctionDescriptionListDataType {
	std::optional<HvacSystemFunctionDescriptionDataType> hvacSystemFunctionDescriptionData ;
};
struct HvacSystemFunctionDescriptionListDataSelectorsType {
	std::optional<HvacSystemFunctionIdType> systemFunctionId ;
};
struct HvacOperationModeDescriptionDataType {
	std::optional<HvacOperationModeIdType> operationModeId ;
	std::optional<HvacOperationModeTypeType> operationModeType ;
	std::optional<LabelType> label ;
	std::optional<DescriptionType> description ;
};
struct HvacOperationModeDescriptionDataElementsType {
	std::optional<ElementTagType> operationModeId ;
	std::optional<ElementTagType> operationModeType ;
	std::optional<ElementTagType> label ;
	std::optional<ElementTagType> description ;
};
struct HvacOperationModeDescriptionListDataType {
	std::optional<HvacOperationModeDescriptionDataType> hvacOperationModeDescriptionData ;
};
struct HvacOperationModeDescriptionListDataSelectorsType {
	std::optional<HvacOperationModeIdType> operationModeId ;
};
struct HvacOverrunDataType {
	std::optional<HvacOverrunIdType> overrunId ;
	std::optional<HvacOverrunStatusType> overrunStatus ;
	std::optional<TimeTableIdType> timeTableId ;
	std::optional<boolean> isOverrunStatusChangeable ;
};
struct HvacOverrunDataElementsType {
	std::optional<ElementTagType> overrunId ;
	std::optional<ElementTagType> overrunStatus ;
	std::optional<ElementTagType> timeTableId ;
	std::optional<ElementTagType> isOverrunStatusChangeable ;
};
struct HvacOverrunListDataType {
	std::optional<HvacOverrunDataType> hvacOverrunData ;
};
struct HvacOverrunListDataSelectorsType {
	std::optional<HvacOverrunIdType> overrunId ;
};
struct HvacOverrunDescriptionDataType {
	std::optional<HvacOverrunIdType> overrunId ;
	std::optional<HvacOverrunTypeType> overrunType ;
	std::optional<HvacSystemFunctionIdType> affectedSystemFunctionId ;
	std::optional<LabelType> label ;
	std::optional<DescriptionType> description ;
};
struct HvacOverrunDescriptionDataElementsType {
	std::optional<ElementTagType> overrunId ;
	std::optional<ElementTagType> overrunType ;
	std::optional<ElementTagType> affectedSystemFunctionId ;
	std::optional<ElementTagType> label ;
	std::optional<ElementTagType> description ;
};
struct HvacOverrunDescriptionListDataType {
	std::optional<HvacOverrunDescriptionDataType> hvacOverrunDescriptionData ;
};
struct HvacOverrunDescriptionListDataSelectorsType {
	std::optional<HvacOverrunIdType> overrunId ;
};
struct SetpointDataType {
	std::optional<SetpointIdType> setpointId ;
	std::optional<ScaledNumberType> value ;
	std::optional<ScaledNumberType> valueMin ;
	std::optional<ScaledNumberType> valueMax ;
	std::optional<ScaledNumberType> valueToleranceAbsolute ;
	std::optional<ScaledNumberType> valueTolerancePercentage ;
	std::optional<boolean> isSetpointChangeable ;
	std::optional<boolean> isSetpointActive ;
	std::optional<TimePeriodType> timePeriod ;
};
struct SetpointDataElementsType {
	std::optional<ElementTagType> setpointId ;
	std::optional<ScaledNumberElementsType> value ;
	std::optional<ScaledNumberElementsType> valueMin ;
	std::optional<ScaledNumberElementsType> valueMax ;
	std::optional<ScaledNumberElementsType> valueToleranceAbsolute ;
	std::optional<ScaledNumberElementsType> valueTolerancePercentage ;
	std::optional<ElementTagType> isSetpointChangeable ;
	std::optional<ElementTagType> isSetpointActive ;
	std::optional<TimePeriodElementsType> timePeriod ;
};
struct SetpointListDataType {
	std::optional<SetpointDataType> setpointData ;
};
struct SetpointListDataSelectorsType {
	std::optional<SetpointIdType> setpointId ;
};
struct SetpointConstraintsDataType {
	std::optional<SetpointIdType> setpointId ;
	std::optional<ScaledNumberType> setpointRangeMin ;
	std::optional<ScaledNumberType> setpointRangeMax ;
	std::optional<ScaledNumberType> setpointStepSize ;
};
struct SetpointConstraintsDataElementsType {
	std::optional<ElementTagType> setpointId ;
	std::optional<ScaledNumberElementsType> setpointRangeMin ;
	std::optional<ScaledNumberElementsType> setpointRangeMax ;
	std::optional<ScaledNumberElementsType> setpointStepSize ;
};
struct SetpointConstraintsListDataType {
	std::optional<SetpointConstraintsDataType> setpointConstraintsData ;
};
struct SetpointConstraintsListDataSelectorsType {
	std::optional<SetpointIdType> setpointId ;
};
struct SetpointDescriptionDataType {
	std::optional<SetpointIdType> setpointId ;
	std::optional<MeasurementIdType> measurementId ;
	std::optional<TimeTableIdType> timeTableId ;
	std::optional<SetpointTypeType> setpointType ;
	std::optional<UnitOfMeasurementType> unit ;
	std::optional<ScopeTypeType> scopeType ;
	std::optional<LabelType> label ;
	std::optional<DescriptionType> description ;
};
struct SetpointDescriptionDataElementsType {
	std::optional<ElementTagType> setpointId ;
	std::optional<ElementTagType> measurementId ;
	std::optional<ElementTagType> timeTableId ;
	std::optional<ElementTagType> setpointType ;
	std::optional<ElementTagType> unit ;
	std::optional<ElementTagType> scopeType ;
	std::optional<ElementTagType> label ;
	std::optional<ElementTagType> description ;
};
struct SetpointDescriptionListDataType {
	std::optional<SetpointDescriptionDataType> setpointDescriptionData ;
};
struct SetpointDescriptionListDataSelectorsType {
	std::optional<SetpointIdType> setpointId ;
	std::optional<MeasurementIdType> measurementId ;
	std::optional<TimeTableIdType> timeTableId ;
	std::optional<SetpointTypeType> setpointType ;
	std::optional<ScopeTypeType> scopeType ;
};
struct TimeTableDataType {
	std::optional<TimeTableIdType> timeTableId ;
	std::optional<TimeSlotIdType> timeSlotId ;
	std::optional<RecurrenceInformationType> recurrenceInformation ;
	std::optional<AbsoluteOrRecurringTimeType> startTime ;
	std::optional<AbsoluteOrRecurringTimeType> endTime ;
};
struct TimeTableDataElementsType {
	std::optional<ElementTagType> timeTableId ;
	std::optional<ElementTagType> timeSlotId ;
	std::optional<RecurrenceInformationElementsType> recurrenceInformation ;
	std::optional<AbsoluteOrRecurringTimeElementsType> startTime ;
	std::optional<AbsoluteOrRecurringTimeElementsType> endTime ;
};
struct TimeTableListDataType {
	std::optional<TimeTableDataType> timeTableData ;
};
struct TimeTableListDataSelectorsType {
	std::optional<TimeTableIdType> timeTableId ;
	std::optional<TimeSlotIdType> timeSlotId ;
};
struct TimeTableConstraintsDataType {
	std::optional<unsignedInt> timeTableId ;
	std::optional<TimeSlotCountType> slotCountMin ;
	std::optional<TimeSlotCountType> slotCountMax ;
	std::optional<duration> slotDurationMin ;
	std::optional<duration> slotDurationMax ;
	std::optional<duration> slotDurationStepSize ;
	std::optional<duration> slotShiftStepSize ;
	std::optional<time> firstSlotBeginsAt ;
};
struct TimeTableConstraintsDataElementsType {
	std::optional<ElementTagType> timeTableId ;
	std::optional<ElementTagType> slotCountMin ;
	std::optional<ElementTagType> slotCountMax ;
	std::optional<ElementTagType> slotDurationMin ;
	std::optional<ElementTagType> slotDurationMax ;
	std::optional<ElementTagType> slotDurationStepSize ;
	std::optional<ElementTagType> slotShiftStepSize ;
	std::optional<ElementTagType> firstSlotBeginsAt ;
};
struct TimeTableConstraintsListDataType {
	std::optional<TimeTableConstraintsDataType> timeTableConstraintsData ;
};
struct TimeTableConstraintsListDataSelectorsType {
	std::optional<TimeTableIdType> timeTableId ;
};
struct TimeTableDescriptionDataType {
	std::optional<unsignedInt> timeTableId ;
	std::optional<boolean> timeSlotCountChangeable ;
	std::optional<boolean> timeSlotTimesChangeable ;
	std::optional<TimeSlotTimeModeType> timeSlotTimeMode ;
	std::optional<LabelType> label ;
	std::optional<DescriptionType> description ;
};
struct TimeTableDescriptionDataElementsType {
	std::optional<ElementTagType> timeTableId ;
	std::optional<ElementTagType> timeSlotCountChangeable ;
	std::optional<ElementTagType> timeSlotTimesChangeable ;
	std::optional<ElementTagType> timeSlotTimeMode ;
	std::optional<ElementTagType> label ;
	std::optional<ElementTagType> description ;
};
struct TimeTableDescriptionListDataType {
	std::optional<TimeTableDescriptionDataType> timeTableDescriptionData ;
};
struct TimeTableDescriptionListDataSelectorsType {
	std::optional<TimeTableIdType> timeTableId ;
};
struct IncentiveTableType {
	std::optional<None> tariff ;
	std::optional<IncentiveTableIncentiveSlotType> incentiveSlot ;
};
struct IncentiveTableIncentiveSlotType {
	std::optional<None> timeInterval ;
	std::optional<IncentiveTableTierType> tier ;
};
struct IncentiveTableTierType {
	std::optional<None> tier ;
	std::optional<None> boundary ;
	std::optional<None> incentive ;
};
struct IncentiveTableDataType {
	std::optional<IncentiveTableType> incentiveTable ;
};
struct IncentiveTableElementsType {
	std::optional<None> tariff ;
	std::optional<IncentiveTableIncentiveSlotElementsType> incentiveSlot ;
};
struct IncentiveTableIncentiveSlotElementsType {
	std::optional<None> timeInterval ;
	std::optional<IncentiveTableTierElementsType> tier ;
};
struct IncentiveTableTierElementsType {
	std::optional<None> tier ;
	std::optional<None> boundary ;
	std::optional<None> incentive ;
};
struct IncentiveTableDataElementsType {
	std::optional<IncentiveTableElementsType> incentiveTable ;
};
struct IncentiveTableDataSelectorsType {
	std::optional<None> tariff ;
};
struct IncentiveTableDescriptionType {
	std::optional<None> tariffDescription ;
	std::optional<IncentiveTableDescriptionTierType> tier ;
};
struct IncentiveTableDescriptionTierType {
	std::optional<None> tierDescription ;
	std::optional<None> boundaryDescription ;
	std::optional<None> incentiveDescription ;
};
struct IncentiveTableDescriptionDataType {
	std::optional<IncentiveTableDescriptionType> incentiveTableDescription ;
};
struct IncentiveTableDescriptionElementsType {
	std::optional<None> tariffDescription ;
	std::optional<IncentiveTableDescriptionTierElementsType> tier ;
};
struct IncentiveTableDescriptionTierElementsType {
	std::optional<None> tierDescription ;
	std::optional<None> boundaryDescription ;
	std::optional<None> incentiveDescription ;
};
struct IncentiveTableDescriptionDataElementsType {
	std::optional<IncentiveTableDescriptionElementsType> incentiveTableDescription ;
};
struct IncentiveTableDescriptionDataSelectorsType {
	std::optional<None> tariffDescription ;
};
struct IncentiveTableConstraintsType {
	std::optional<None> tariff ;
	std::optional<None> tariffConstraints ;
	std::optional<None> incentiveSlotConstraints ;
};
struct IncentiveTableConstraintsDataType {
	std::optional<IncentiveTableConstraintsType> incentiveTableConstraints ;
};
struct IncentiveTableConstraintsElementsType {
	std::optional<None> tariff ;
	std::optional<None> tariffConstraints ;
	std::optional<None> incentiveSlotConstraints ;
};
struct IncentiveTableConstraintsDataElementsType {
	std::optional<IncentiveTableConstraintsElementsType> incentiveTableConstraints ;
};
struct IncentiveTableConstraintsDataSelectorsType {
	std::optional<None> tariff ;
};
struct TariffOverallConstraintsDataType {
	std::optional<TariffCountType> maxTariffCount ;
	std::optional<TierBoundaryCountType> maxBoundaryCount ;
	std::optional<TierCountType> maxTierCount ;
	std::optional<IncentiveCountType> maxIncentiveCount ;
	std::optional<TierBoundaryCountType> maxBoundariesPerTariff ;
	std::optional<TierCountType> maxTiersPerTariff ;
	std::optional<TierBoundaryCountType> maxBoundariesPerTier ;
	std::optional<IncentiveCountType> maxIncentivesPerTier ;
};
struct TariffOverallConstraintsDataElementsType {
	std::optional<ElementTagType> maxTariffCount ;
	std::optional<ElementTagType> maxBoundaryCount ;
	std::optional<ElementTagType> maxTierCount ;
	std::optional<ElementTagType> maxIncentiveCount ;
	std::optional<ElementTagType> maxBoundariesPerTariff ;
	std::optional<ElementTagType> maxTiersPerTariff ;
	std::optional<ElementTagType> maxBoundariesPerTier ;
	std::optional<ElementTagType> maxIncentivesPerTier ;
};
struct TariffDataType {
	std::optional<TariffIdType> tariffId ;
	std::optional<TierIdType> activeTierId ;
};
struct TariffDataElementsType {
	std::optional<ElementTagType> tariffId ;
	std::optional<ElementTagType> activeTierId ;
};
struct TariffListDataType {
	std::optional<TariffDataType> tariffData ;
};
struct TariffListDataSelectorsType {
	std::optional<TariffIdType> tariffId ;
	std::optional<TierIdType> activeTierId ;
};
struct TariffTierRelationDataType {
	std::optional<TariffIdType> tariffId ;
	std::optional<TierIdType> tierId ;
};
struct TariffTierRelationDataElementsType {
	std::optional<ElementTagType> tariffId ;
	std::optional<ElementTagType> tierId ;
};
struct TariffTierRelationListDataType {
	std::optional<TariffTierRelationDataType> tariffTierRelationData ;
};
struct TariffTierRelationListDataSelectorsType {
	std::optional<TariffIdType> tariffId ;
	std::optional<TierIdType> tierId ;
};
struct TariffBoundaryRelationDataType {
	std::optional<TariffIdType> tariffId ;
	std::optional<TierBoundaryIdType> boundaryId ;
};
struct TariffBoundaryRelationDataElementsType {
	std::optional<ElementTagType> tariffId ;
	std::optional<ElementTagType> boundaryId ;
};
struct TariffBoundaryRelationListDataType {
	std::optional<TariffBoundaryRelationDataType> tariffBoundaryRelationData ;
};
struct TariffBoundaryRelationListDataSelectorsType {
	std::optional<TariffIdType> tariffId ;
	std::optional<TierBoundaryIdType> boundaryId ;
};
struct TariffDescriptionDataType {
	std::optional<TariffIdType> tariffId ;
	std::optional<CommodityIdType> commodityId ;
	std::optional<MeasurementIdType> measurementId ;
	std::optional<boolean> tariffWriteable ;
	std::optional<boolean> updateRequired ;
	std::optional<ScopeTypeType> scopeType ;
	std::optional<LabelType> label ;
	std::optional<DescriptionType> description ;
	std::optional<boolean> slotIdSupport ;
};
struct TariffDescriptionDataElementsType {
	std::optional<ElementTagType> tariffId ;
	std::optional<ElementTagType> commodityId ;
	std::optional<ElementTagType> measurementId ;
	std::optional<ElementTagType> tariffWriteable ;
	std::optional<ElementTagType> updateRequired ;
	std::optional<ElementTagType> scopeType ;
	std::optional<ElementTagType> label ;
	std::optional<ElementTagType> description ;
	std::optional<ElementTagType> slotIdSupport ;
};
struct TariffDescriptionListDataType {
	std::optional<TariffDescriptionDataType> tariffDescriptionData ;
};
struct TariffDescriptionListDataSelectorsType {
	std::optional<TariffIdType> tariffId ;
	std::optional<CommodityIdType> commodityId ;
	std::optional<MeasurementIdType> measurementId ;
	std::optional<ScopeTypeType> scopeType ;
};
struct TierBoundaryDataType {
	std::optional<TierBoundaryIdType> boundaryId ;
	std::optional<TimePeriodType> timePeriod ;
	std::optional<TimeTableIdType> timeTableId ;
	std::optional<ScaledNumberType> lowerBoundaryValue ;
	std::optional<ScaledNumberType> upperBoundaryValue ;
};
struct TierBoundaryDataElementsType {
	std::optional<ElementTagType> boundaryId ;
	std::optional<TimePeriodElementsType> timePeriod ;
	std::optional<ElementTagType> timeTableId ;
	std::optional<ScaledNumberElementsType> lowerBoundaryValue ;
	std::optional<ScaledNumberElementsType> upperBoundaryValue ;
};
struct TierBoundaryListDataType {
	std::optional<TierBoundaryDataType> tierBoundaryData ;
};
struct TierBoundaryListDataSelectorsType {
	std::optional<TierBoundaryIdType> boundaryId ;
};
struct TierBoundaryDescriptionDataType {
	std::optional<TierBoundaryIdType> boundaryId ;
	std::optional<TierBoundaryTypeType> boundaryType ;
	std::optional<TierIdType> validForTierId ;
	std::optional<TierIdType> switchToTierIdWhenLower ;
	std::optional<TierIdType> switchToTierIdWhenHigher ;
	std::optional<UnitOfMeasurementType> boundaryUnit ;
	std::optional<LabelType> label ;
	std::optional<DescriptionType> description ;
};
struct TierBoundaryDescriptionDataElementsType {
	std::optional<ElementTagType> boundaryId ;
	std::optional<ElementTagType> boundaryType ;
	std::optional<ElementTagType> validForTierId ;
	std::optional<ElementTagType> switchToTierIdWhenLower ;
	std::optional<ElementTagType> switchToTierIdWhenHigher ;
	std::optional<ElementTagType> boundaryUnit ;
	std::optional<ElementTagType> label ;
	std::optional<ElementTagType> description ;
};
struct TierBoundaryDescriptionListDataType {
	std::optional<TierBoundaryDescriptionDataType> tierBoundaryDescriptionData ;
};
struct TierBoundaryDescriptionListDataSelectorsType {
	std::optional<TierBoundaryIdType> boundaryId ;
	std::optional<TierBoundaryTypeType> boundaryType ;
};
struct CommodityDataType {
	std::optional<CommodityIdType> commodityId ;
	std::optional<CommodityTypeType> commodityType ;
	std::optional<EnergyDirectionType> positiveEnergyDirection ;
	std::optional<LabelType> label ;
	std::optional<DescriptionType> description ;
};
struct CommodityDataElementsType {
	std::optional<ElementTagType> commodityId ;
	std::optional<ElementTagType> commodityType ;
	std::optional<ElementTagType> positiveEnergyDirection ;
	std::optional<ElementTagType> label ;
	std::optional<ElementTagType> description ;
};
struct CommodityListDataType {
	std::optional<CommodityDataType> commodityData ;
};
struct CommodityListDataSelectorsType {
	std::optional<CommodityIdType> commodityId ;
	std::optional<CommodityTypeType> commodityType ;
};
struct TierDataType {
	std::optional<TierIdType> tierId ;
	std::optional<TimePeriodType> timePeriod ;
	std::optional<TimeTableIdType> timeTableId ;
	std::optional<IncentiveIdType> activeIncentiveId ;
};
struct TierDataElementsType {
	std::optional<ElementTagType> tierId ;
	std::optional<TimePeriodElementsType> timePeriod ;
	std::optional<ElementTagType> timeTableId ;
	std::optional<ElementTagType> activeIncentiveId ;
};
struct TierListDataType {
	std::optional<TierDataType> tierData ;
};
struct TierListDataSelectorsType {
	std::optional<TierIdType> tierId ;
	std::optional<IncentiveIdType> activeIncentiveId ;
};
struct TierIncentiveRelationDataType {
	std::optional<TierIdType> tierId ;
	std::optional<IncentiveIdType> incentiveId ;
};
struct TierIncentiveRelationDataElementsType {
	std::optional<ElementTagType> tierId ;
	std::optional<ElementTagType> incentiveId ;
};
struct TierIncentiveRelationListDataType {
	std::optional<TierIncentiveRelationDataType> tierIncentiveRelationData ;
};
struct TierIncentiveRelationListDataSelectorsType {
	std::optional<TierIdType> tierId ;
	std::optional<IncentiveIdType> incentiveId ;
};
struct TierDescriptionDataType {
	std::optional<TierIdType> tierId ;
	std::optional<TierTypeType> tierType ;
	std::optional<LabelType> label ;
	std::optional<DescriptionType> description ;
};
struct TierDescriptionDataElementsType {
	std::optional<ElementTagType> tierId ;
	std::optional<ElementTagType> tierType ;
	std::optional<ElementTagType> label ;
	std::optional<ElementTagType> description ;
};
struct TierDescriptionListDataType {
	std::optional<TierDescriptionDataType> tierDescriptionData ;
};
struct TierDescriptionListDataSelectorsType {
	std::optional<TierIdType> tierId ;
	std::optional<TierTypeType> tierType ;
};
struct IncentiveDataType {
	std::optional<IncentiveIdType> incentiveId ;
	std::optional<IncentiveValueTypeType> valueType ;
	std::optional<AbsoluteOrRelativeTimeType> timestamp ;
	std::optional<TimePeriodType> timePeriod ;
	std::optional<TimeTableIdType> timeTableId ;
	std::optional<ScaledNumberType> value ;
};
struct IncentiveDataElementsType {
	std::optional<ElementTagType> incentiveId ;
	std::optional<ElementTagType> valueType ;
	std::optional<ElementTagType> timestamp ;
	std::optional<TimePeriodElementsType> timePeriod ;
	std::optional<ElementTagType> timeTableId ;
	std::optional<ElementTagType> value ;
};
struct IncentiveListDataType {
	std::optional<IncentiveDataType> incentiveData ;
};
struct IncentiveListDataSelectorsType {
	std::optional<IncentiveIdType> incentiveId ;
	std::optional<IncentiveValueTypeType> valueType ;
	std::optional<TimestampIntervalType> timestampInterval ;
};
struct IncentiveDescriptionDataType {
	std::optional<IncentiveIdType> incentiveId ;
	std::optional<IncentiveTypeType> incentiveType ;
	std::optional<IncentivePriorityType> incentivePriority ;
	std::optional<CurrencyType> currency ;
	std::optional<UnitOfMeasurementType> unit ;
	std::optional<LabelType> label ;
	std::optional<DescriptionType> description ;
};
struct IncentiveDescriptionDataElementsType {
	std::optional<ElementTagType> incentiveId ;
	std::optional<ElementTagType> incentiveType ;
	std::optional<ElementTagType> incentivePriority ;
	std::optional<ElementTagType> currency ;
	std::optional<ElementTagType> unit ;
	std::optional<ElementTagType> label ;
	std::optional<ElementTagType> description ;
};
struct IncentiveDescriptionListDataType {
	std::optional<IncentiveDescriptionDataType> incentiveDescriptionData ;
};
struct IncentiveDescriptionListDataSelectorsType {
	std::optional<IncentiveIdType> incentiveId ;
	std::optional<IncentiveTypeType> incentiveType ;
};
struct LoadControlNodeDataType {
	std::optional<boolean> isNodeRemoteControllable ;
};
struct LoadControlNodeDataElementsType {
	std::optional<ElementTagType> isNodeRemoteControllable ;
};
struct LoadControlEventDataType {
	std::optional<AbsoluteOrRelativeTimeType> timestamp ;
	std::optional<LoadControlEventIdType> eventId ;
	std::optional<LoadControlEventActionType> eventActionConsume ;
	std::optional<LoadControlEventActionType> eventActionProduce ;
	std::optional<TimePeriodType> timePeriod ;
};
struct LoadControlEventDataElementsType {
	std::optional<ElementTagType> timestamp ;
	std::optional<ElementTagType> eventId ;
	std::optional<ElementTagType> eventActionConsume ;
	std::optional<ElementTagType> eventActionProduce ;
	std::optional<TimePeriodElementsType> timePeriod ;
};
struct LoadControlEventListDataType {
	std::optional<LoadControlEventDataType> loadControlEventData ;
};
struct LoadControlEventListDataSelectorsType {
	std::optional<TimestampIntervalType> timestampInterval ;
	std::optional<LoadControlEventIdType> eventId ;
};
struct LoadControlStateDataType {
	std::optional<AbsoluteOrRelativeTimeType> timestamp ;
	std::optional<LoadControlEventIdType> eventId ;
	std::optional<LoadControlEventStateType> eventStateConsume ;
	std::optional<LoadControlEventActionType> appliedEventActionConsume ;
	std::optional<LoadControlEventStateType> eventStateProduce ;
	std::optional<LoadControlEventActionType> appliedEventActionProduce ;
};
struct LoadControlStateDataElementsType {
	std::optional<ElementTagType> timestamp ;
	std::optional<ElementTagType> eventId ;
	std::optional<ElementTagType> eventStateConsume ;
	std::optional<ElementTagType> appliedEventActionConsume ;
	std::optional<ElementTagType> eventStateProduce ;
	std::optional<ElementTagType> appliedEventActionProduce ;
};
struct LoadControlStateListDataType {
	std::optional<LoadControlStateDataType> loadControlStateData ;
};
struct LoadControlStateListDataSelectorsType {
	std::optional<TimestampIntervalType> timestampInterval ;
	std::optional<LoadControlEventIdType> eventId ;
};
struct LoadControlLimitDataType {
	std::optional<LoadControlLimitIdType> limitId ;
	std::optional<boolean> isLimitChangeable ;
	std::optional<boolean> isLimitActive ;
	std::optional<TimePeriodType> timePeriod ;
	std::optional<ScaledNumberType> value ;
};
struct LoadControlLimitDataElementsType {
	std::optional<ElementTagType> limitId ;
	std::optional<ElementTagType> isLimitChangeable ;
	std::optional<ElementTagType> isLimitActive ;
	std::optional<TimePeriodElementsType> timePeriod ;
	std::optional<ScaledNumberElementsType> value ;
};
struct LoadControlLimitListDataType {
	std::optional<LoadControlLimitDataType> loadControlLimitData ;
};
struct LoadControlLimitListDataSelectorsType {
	std::optional<LoadControlLimitIdType> limitId ;
};
struct LoadControlLimitConstraintsDataType {
	std::optional<LoadControlLimitIdType> limitId ;
	std::optional<ScaledNumberType> valueRangeMin ;
	std::optional<ScaledNumberType> valueRangeMax ;
	std::optional<ScaledNumberType> valueStepSize ;
};
struct LoadControlLimitConstraintsDataElementsType {
	std::optional<ElementTagType> limitId ;
	std::optional<ScaledNumberElementsType> valueRangeMin ;
	std::optional<ScaledNumberElementsType> valueRangeMax ;
	std::optional<ScaledNumberElementsType> valueStepSize ;
};
struct LoadControlLimitConstraintsListDataType {
	std::optional<LoadControlLimitConstraintsDataType> loadControlLimitConstraintsData ;
};
struct LoadControlLimitConstraintsListDataSelectorsType {
	std::optional<LoadControlLimitIdType> limitId ;
};
struct LoadControlLimitDescriptionDataType {
	std::optional<LoadControlLimitIdType> limitId ;
	std::optional<LoadControlLimitTypeType> limitType ;
	std::optional<LoadControlCategoryType> limitCategory ;
	std::optional<EnergyDirectionType> limitDirection ;
	std::optional<MeasurementIdType> measurementId ;
	std::optional<UnitOfMeasurementType> unit ;
	std::optional<ScopeTypeType> scopeType ;
	std::optional<LabelType> label ;
	std::optional<DescriptionType> description ;
};
struct LoadControlLimitDescriptionDataElementsType {
	std::optional<ElementTagType> limitId ;
	std::optional<ElementTagType> limitType ;
	std::optional<ElementTagType> limitCategory ;
	std::optional<ElementTagType> limitDirection ;
	std::optional<ElementTagType> measurementId ;
	std::optional<ElementTagType> unit ;
	std::optional<ElementTagType> scopeType ;
	std::optional<ElementTagType> label ;
	std::optional<ElementTagType> description ;
};
struct LoadControlLimitDescriptionListDataType {
	std::optional<LoadControlLimitDescriptionDataType> loadControlLimitDescriptionData ;
};
struct LoadControlLimitDescriptionListDataSelectorsType {
	std::optional<LoadControlLimitIdType> limitId ;
	std::optional<LoadControlLimitTypeType> limitType ;
	std::optional<EnergyDirectionType> limitDirection ;
	std::optional<MeasurementIdType> measurementId ;
	std::optional<ScopeTypeType> scopeType ;
};
struct NetworkManagementAddNodeCallType {
	std::optional<FeatureAddressType> nodeAddress ;
	std::optional<NetworkManagementNativeSetupType> nativeSetup ;
	std::optional<NetworkManagementProcessTimeoutType> timeout ;
	std::optional<LabelType> label ;
	std::optional<DescriptionType> description ;
};
struct NetworkManagementAddNodeCallElementsType {
	std::optional<FeatureAddressElementsType> nodeAddress ;
	std::optional<ElementTagType> nativeSetup ;
	std::optional<ElementTagType> timeout ;
	std::optional<ElementTagType> label ;
	std::optional<ElementTagType> description ;
};
struct NetworkManagementRemoveNodeCallType {
	std::optional<FeatureAddressType> nodeAddress ;
	std::optional<NetworkManagementProcessTimeoutType> timeout ;
};
struct NetworkManagementRemoveNodeCallElementsType {
	std::optional<FeatureAddressElementsType> nodeAddress ;
	std::optional<ElementTagType> timeout ;
};
struct NetworkManagementModifyNodeCallType {
	std::optional<FeatureAddressType> nodeAddress ;
	std::optional<NetworkManagementNativeSetupType> nativeSetup ;
	std::optional<NetworkManagementProcessTimeoutType> timeout ;
	std::optional<LabelType> label ;
	std::optional<DescriptionType> description ;
};
struct NetworkManagementModifyNodeCallElementsType {
	std::optional<FeatureAddressElementsType> nodeAddress ;
	std::optional<ElementTagType> nativeSetup ;
	std::optional<ElementTagType> timeout ;
	std::optional<ElementTagType> label ;
	std::optional<ElementTagType> description ;
};
struct NetworkManagementScanNetworkCallType {
	std::optional<NetworkManagementScanSetupType> scanSetup ;
	std::optional<NetworkManagementProcessTimeoutType> timeout ;
};
struct NetworkManagementScanNetworkCallElementsType {
	std::optional<ElementTagType> scanSetup ;
	std::optional<ElementTagType> timeout ;
};
struct NetworkManagementDiscoverCallType {
	std::optional<FeatureAddressType> discoverAddress ;
};
struct NetworkManagementDiscoverCallElementsType {
	std::optional<FeatureAddressElementsType> discoverAddress ;
};
struct NetworkManagementAbortCallType {
};
struct NetworkManagementAbortCallElementsType {
};
struct NetworkManagementProcessStateDataType {
	std::optional<NetworkManagementProcessStateStateType> state ;
	std::optional<DescriptionType> description ;
};
struct NetworkManagementProcessStateDataElementsType {
	std::optional<ElementTagType> state ;
	std::optional<ElementTagType> description ;
};
struct NetworkManagementJoiningModeDataType {
	std::optional<NetworkManagementSetupType> setup ;
};
struct NetworkManagementJoiningModeDataElementsType {
	std::optional<ElementTagType> setup ;
};
struct NetworkManagementReportCandidateDataType {
	std::optional<NetworkManagementCandidateSetupType> candidateSetup ;
	std::optional<boolean> setupUsableForAdd ;
	std::optional<LabelType> label ;
	std::optional<DescriptionType> description ;
};
struct NetworkManagementReportCandidateDataElementsType {
	std::optional<ElementTagType> candidateSetup ;
	std::optional<ElementTagType> setupUsableForAdd ;
	std::optional<ElementTagType> label ;
	std::optional<ElementTagType> description ;
};
struct NetworkManagementDeviceDescriptionDataType {
	std::optional<DeviceAddressType> deviceAddress ;
	std::optional<DeviceTypeType> deviceType ;
	std::optional<FeatureAddressType> networkManagementResponsibleAddress ;
	std::optional<NetworkManagementNativeSetupType> nativeSetup ;
	std::optional<NetworkManagementTechnologyAddressType> technologyAddress ;
	std::optional<NetworkManagementCommunicationsTechnologyInformationType> communicationsTechnologyInformation ;
	std::optional<NetworkManagementFeatureSetType> networkFeatureSet ;
	std::optional<NetworkManagementStateChangeType> lastStateChange ;
	std::optional<NetworkManagementMinimumTrustLevelType> minimumTrustLevel ;
	std::optional<LabelType> label ;
	std::optional<DescriptionType> description ;
};
struct NetworkManagementDeviceDescriptionDataElementsType {
	std::optional<DeviceAddressElementsType> deviceAddress ;
	std::optional<ElementTagType> deviceType ;
	std::optional<ElementTagType> networkManagementResponsibleAddress ;
	std::optional<ElementTagType> nativeSetup ;
	std::optional<ElementTagType> technologyAddress ;
	std::optional<ElementTagType> communicationsTechnologyInformation ;
	std::optional<ElementTagType> networkFeatureSet ;
	std::optional<ElementTagType> lastStateChange ;
	std::optional<ElementTagType> minimumTrustLevel ;
	std::optional<ElementTagType> label ;
	std::optional<ElementTagType> description ;
};
struct NetworkManagementDeviceDescriptionListDataType {
	std::optional<NetworkManagementDeviceDescriptionDataType> networkManagementDeviceDescriptionData ;
};
struct NetworkManagementDeviceDescriptionListDataSelectorsType {
	std::optional<DeviceAddressType> deviceAddress ;
	std::optional<DeviceTypeType> deviceType ;
};
struct NetworkManagementEntityDescriptionDataType {
	std::optional<EntityAddressType> entityAddress ;
	std::optional<EntityTypeType> entityType ;
	std::optional<NetworkManagementStateChangeType> lastStateChange ;
	std::optional<NetworkManagementMinimumTrustLevelType> minimumTrustLevel ;
	std::optional<LabelType> label ;
	std::optional<DescriptionType> description ;
};
struct NetworkManagementEntityDescriptionDataElementsType {
	std::optional<EntityAddressElementsType> entityAddress ;
	std::optional<ElementTagType> entityType ;
	std::optional<ElementTagType> lastStateChange ;
	std::optional<ElementTagType> minimumTrustLevel ;
	std::optional<ElementTagType> label ;
	std::optional<ElementTagType> description ;
};
struct NetworkManagementEntityDescriptionListDataType {
	std::optional<NetworkManagementEntityDescriptionDataType> networkManagementEntityDescriptionData ;
};
struct NetworkManagementEntityDescriptionListDataSelectorsType {
	std::optional<EntityAddressType> entityAddress ;
	std::optional<EntityTypeType> entityType ;
};
struct NetworkManagementFeatureDescriptionDataType {
	std::optional<FeatureAddressType> featureAddress ;
	std::optional<FeatureTypeType> featureType ;
	std::optional<FeatureSpecificUsageType> specificUsage ;
	std::optional<FeatureGroupType> featureGroup ;
	std::optional<RoleType> role ;
	std::optional<FunctionPropertyType> supportedFunction ;
	std::optional<NetworkManagementStateChangeType> lastStateChange ;
	std::optional<NetworkManagementMinimumTrustLevelType> minimumTrustLevel ;
	std::optional<LabelType> label ;
	std::optional<DescriptionType> description ;
	std::optional<MaxResponseDelayType> maxResponseDelay ;
};
struct NetworkManagementFeatureDescriptionDataElementsType {
	std::optional<FeatureAddressElementsType> featureAddress ;
	std::optional<ElementTagType> featureType ;
	std::optional<ElementTagType> specificUsage ;
	std::optional<ElementTagType> featureGroup ;
	std::optional<ElementTagType> role ;
	std::optional<FunctionPropertyElementsType> supportedFunction ;
	std::optional<ElementTagType> lastStateChange ;
	std::optional<ElementTagType> minimumTrustLevel ;
	std::optional<ElementTagType> label ;
	std::optional<ElementTagType> description ;
	std::optional<ElementTagType> maxResponseDelay ;
};
struct NetworkManagementFeatureDescriptionListDataType {
	std::optional<NetworkManagementFeatureDescriptionDataType> networkManagementFeatureDescriptionData ;
};
struct NetworkManagementFeatureDescriptionListDataSelectorsType {
	std::optional<FeatureAddressType> featureAddress ;
	std::optional<FeatureTypeType> featureType ;
};
struct NodeManagementSpecificationVersionListType {
	std::optional<SpecificationVersionDataType> specificationVersion ;
};
struct NodeManagementDetailedDiscoveryDeviceInformationType {
	std::optional<None> description ;
};
struct NodeManagementDetailedDiscoveryEntityInformationType {
	std::optional<None> description ;
};
struct NodeManagementDetailedDiscoveryFeatureInformationType {
	std::optional<None> description ;
};
struct NodeManagementDetailedDiscoveryDataType {
	std::optional<NodeManagementSpecificationVersionListType> specificationVersionList ;
	std::optional<NodeManagementDetailedDiscoveryDeviceInformationType> deviceInformation ;
	std::optional<NodeManagementDetailedDiscoveryEntityInformationType> entityInformation ;
	std::optional<NodeManagementDetailedDiscoveryFeatureInformationType> featureInformation ;
};
struct NodeManagementSpecificationVersionListElementsType {
	std::optional<None> specificationVersion ;
};
struct NodeManagementDetailedDiscoveryDeviceInformationElementsType {
	std::optional<None> description ;
};
struct NodeManagementDetailedDiscoveryEntityInformationElementsType {
	std::optional<None> description ;
};
struct NodeManagementDetailedDiscoveryFeatureInformationElementsType {
	std::optional<None> description ;
};
struct NodeManagementDetailedDiscoveryDataElementsType {
	std::optional<NodeManagementSpecificationVersionListElementsType> specificationVersionList ;
	std::optional<NodeManagementDetailedDiscoveryDeviceInformationElementsType> deviceInformation ;
	std::optional<NodeManagementDetailedDiscoveryEntityInformationElementsType> entityInformation ;
	std::optional<NodeManagementDetailedDiscoveryFeatureInformationElementsType> featureInformation ;
};
struct NodeManagementDetailedDiscoveryDataSelectorsType {
	std::optional<None> deviceInformation ;
	std::optional<None> entityInformation ;
	std::optional<None> featureInformation ;
};
struct NodeManagementBindingDataType {
	std::optional<None> bindingEntry ;
};
struct NodeManagementBindingDataElementsType {
	std::optional<None> bindingEntry ;
};
struct NodeManagementBindingDataSelectorsType {
	std::optional<None> bindingEntry ;
};
struct NodeManagementBindingRequestCallType {
	std::optional<None> bindingRequest ;
};
struct NodeManagementBindingRequestCallElementsType {
	std::optional<None> bindingRequest ;
};
struct NodeManagementBindingDeleteCallType {
	std::optional<None> bindingDelete ;
};
struct NodeManagementBindingDeleteCallElementsType {
	std::optional<None> bindingDelete ;
};
struct NodeManagementSubscriptionDataType {
	std::optional<None> subscriptionEntry ;
};
struct NodeManagementSubscriptionDataElementsType {
	std::optional<None> subscriptionEntry ;
};
struct NodeManagementSubscriptionDataSelectorsType {
	std::optional<None> subscriptionEntry ;
};
struct NodeManagementSubscriptionRequestCallType {
	std::optional<None> subscriptionRequest ;
};
struct NodeManagementSubscriptionRequestCallElementsType {
	std::optional<None> subscriptionRequest ;
};
struct NodeManagementSubscriptionDeleteCallType {
	std::optional<None> subscriptionDelete ;
};
struct NodeManagementSubscriptionDeleteCallElementsType {
	std::optional<None> subscriptionDelete ;
};
struct NodeManagementDestinationDataType {
	std::optional<None> deviceDescription ;
};
struct NodeManagementDestinationDataElementsType {
	std::optional<None> deviceDescription ;
};
struct NodeManagementDestinationListDataType {
	std::optional<NodeManagementDestinationDataType> nodeManagementDestinationData ;
};
struct NodeManagementDestinationListDataSelectorsType {
	std::optional<None> deviceDescription ;
};
struct NodeManagementUseCaseDataType {
	std::optional<None> useCaseInformation ;
};
struct NodeManagementUseCaseDataElementsType {
	std::optional<None> useCaseInformation ;
};
struct NodeManagementUseCaseDataSelectorsType {
	std::optional<None> useCaseInformation ;
};
struct SubscriptionManagementEntryDataType {
	std::optional<SubscriptionIdType> subscriptionId ;
	std::optional<FeatureAddressType> clientAddress ;
	std::optional<FeatureAddressType> serverAddress ;
	std::optional<LabelType> label ;
	std::optional<DescriptionType> description ;
};
struct SubscriptionManagementEntryDataElementsType {
	std::optional<ElementTagType> subscriptionId ;
	std::optional<FeatureAddressElementsType> clientAddress ;
	std::optional<FeatureAddressElementsType> serverAddress ;
	std::optional<ElementTagType> label ;
	std::optional<ElementTagType> description ;
};
struct SubscriptionManagementEntryListDataType {
	std::optional<SubscriptionManagementEntryDataType> subscriptionManagementEntryData ;
};
struct SubscriptionManagementEntryListDataSelectorsType {
	std::optional<SubscriptionIdType> subscriptionId ;
	std::optional<FeatureAddressType> clientAddress ;
	std::optional<FeatureAddressType> serverAddress ;
};
struct SubscriptionManagementRequestCallType {
	std::optional<FeatureAddressType> clientAddress ;
	std::optional<FeatureAddressType> serverAddress ;
	std::optional<FeatureTypeType> serverFeatureType ;
};
struct SubscriptionManagementRequestCallElementsType {
	std::optional<FeatureAddressElementsType> clientAddress ;
	std::optional<FeatureAddressElementsType> serverAddress ;
	std::optional<ElementTagType> serverFeatureType ;
};
struct SubscriptionManagementDeleteCallType {
	std::optional<SubscriptionIdType> subscriptionId ;
	std::optional<FeatureAddressType> clientAddress ;
	std::optional<FeatureAddressType> serverAddress ;
};
struct SubscriptionManagementDeleteCallElementsType {
	std::optional<ElementTagType> subscriptionId ;
	std::optional<FeatureAddressElementsType> clientAddress ;
	std::optional<FeatureAddressElementsType> serverAddress ;
};
struct UseCaseSupportType {
	std::optional<UseCaseNameType> useCaseName ;
	std::optional<SpecificationVersionType> useCaseVersion ;
	std::optional<boolean> useCaseAvailable ;
	std::optional<UseCaseScenarioSupportType> scenarioSupport ;
	std::optional<string> useCaseDocumentSubRevision ;
};
struct UseCaseSupportElementsType {
	std::optional<ElementTagType> useCaseName ;
	std::optional<ElementTagType> useCaseVersion ;
	std::optional<ElementTagType> useCaseAvailable ;
	std::optional<ElementTagType> scenarioSupport ;
	std::optional<ElementTagType> useCaseDocumentSubRevision ;
};
struct UseCaseSupportSelectorsType {
	std::optional<UseCaseNameType> useCaseName ;
	std::optional<SpecificationVersionType> useCaseVersion ;
	std::optional<UseCaseScenarioSupportType> scenarioSupport ;
};
struct UseCaseInformationDataType {
	std::optional<FeatureAddressType> address ;
	std::optional<UseCaseActorType> actor ;
	std::optional<UseCaseSupportType> useCaseSupport ;
};
struct UseCaseInformationDataElementsType {
	std::optional<FeatureAddressElementsType> address ;
	std::optional<ElementTagType> actor ;
	std::optional<UseCaseSupportElementsType> useCaseSupport ;
};
struct UseCaseInformationListDataType {
	std::optional<UseCaseInformationDataType> useCaseInformationData ;
};
struct UseCaseInformationListDataSelectorsType {
	std::optional<FeatureAddressType> address ;
	std::optional<UseCaseActorType> actor ;
	std::optional<UseCaseSupportSelectorsType> useCaseSupport ;
};
struct SpecificationVersionDataElementsType {
};
struct SpecificationVersionListDataType {
	std::optional<SpecificationVersionDataType> specificationVersionData ;
};
struct SpecificationVersionListDataSelectorsType {
};
struct OperatingConstraintsInterruptDataType {
	std::optional<PowerSequenceIdType> sequenceId ;
	std::optional<boolean> isPausable ;
	std::optional<boolean> isStoppable ;
	std::optional<boolean> notInterruptibleAtHighPower ;
	std::optional<unsignedInt> maxCyclesPerDay ;
};
struct OperatingConstraintsInterruptDataElementsType {
	std::optional<ElementTagType> sequenceId ;
	std::optional<ElementTagType> isPausable ;
	std::optional<ElementTagType> isStoppable ;
	std::optional<ElementTagType> notInterruptibleAtHighPower ;
	std::optional<ElementTagType> maxCyclesPerDay ;
};
struct OperatingConstraintsInterruptListDataType {
	std::optional<OperatingConstraintsInterruptDataType> operatingConstraintsInterruptData ;
};
struct OperatingConstraintsInterruptListDataSelectorsType {
	std::optional<PowerSequenceIdType> sequenceId ;
};
struct OperatingConstraintsDurationDataType {
	std::optional<PowerSequenceIdType> sequenceId ;
	std::optional<duration> activeDurationMin ;
	std::optional<duration> activeDurationMax ;
	std::optional<duration> pauseDurationMin ;
	std::optional<duration> pauseDurationMax ;
	std::optional<duration> activeDurationSumMin ;
	std::optional<duration> activeDurationSumMax ;
};
struct OperatingConstraintsDurationDataElementsType {
	std::optional<ElementTagType> sequenceId ;
	std::optional<ElementTagType> activeDurationMin ;
	std::optional<ElementTagType> activeDurationMax ;
	std::optional<ElementTagType> pauseDurationMin ;
	std::optional<ElementTagType> pauseDurationMax ;
	std::optional<ElementTagType> activeDurationSumMin ;
	std::optional<ElementTagType> activeDurationSumMax ;
};
struct OperatingConstraintsDurationListDataType {
	std::optional<OperatingConstraintsDurationDataType> operatingConstraintsDurationData ;
};
struct OperatingConstraintsDurationListDataSelectorsType {
	std::optional<PowerSequenceIdType> sequenceId ;
};
struct OperatingConstraintsPowerDescriptionDataType {
	std::optional<PowerSequenceIdType> sequenceId ;
	std::optional<EnergyDirectionType> positiveEnergyDirection ;
	std::optional<UnitOfMeasurementType> powerUnit ;
	std::optional<UnitOfMeasurementType> energyUnit ;
	std::optional<DescriptionType> description ;
};
struct OperatingConstraintsPowerDescriptionDataElementsType {
	std::optional<ElementTagType> sequenceId ;
	std::optional<ElementTagType> positiveEnergyDirection ;
	std::optional<ElementTagType> powerUnit ;
	std::optional<ElementTagType> energyUnit ;
	std::optional<ElementTagType> description ;
};
struct OperatingConstraintsPowerDescriptionListDataType {
	std::optional<OperatingConstraintsPowerDescriptionDataType> operatingConstraintsPowerDescriptionData ;
};
struct OperatingConstraintsPowerDescriptionListDataSelectorsType {
	std::optional<PowerSequenceIdType> sequenceId ;
};
struct OperatingConstraintsPowerRangeDataType {
	std::optional<PowerSequenceIdType> sequenceId ;
	std::optional<ScaledNumberType> powerMin ;
	std::optional<ScaledNumberType> powerMax ;
	std::optional<ScaledNumberType> energyMin ;
	std::optional<ScaledNumberType> energyMax ;
};
struct OperatingConstraintsPowerRangeDataElementsType {
	std::optional<ElementTagType> sequenceId ;
	std::optional<ScaledNumberElementsType> powerMin ;
	std::optional<ScaledNumberElementsType> powerMax ;
	std::optional<ScaledNumberElementsType> energyMin ;
	std::optional<ScaledNumberElementsType> energyMax ;
};
struct OperatingConstraintsPowerRangeListDataType {
	std::optional<OperatingConstraintsPowerRangeDataType> operatingConstraintsPowerRangeData ;
};
struct OperatingConstraintsPowerRangeListDataSelectorsType {
	std::optional<PowerSequenceIdType> sequenceId ;
};
struct OperatingConstraintsPowerLevelDataType {
	std::optional<PowerSequenceIdType> sequenceId ;
	std::optional<ScaledNumberType> power ;
};
struct OperatingConstraintsPowerLevelDataElementsType {
	std::optional<ElementTagType> sequenceId ;
	std::optional<ScaledNumberElementsType> power ;
};
struct OperatingConstraintsPowerLevelListDataType {
	std::optional<OperatingConstraintsPowerLevelDataType> operatingConstraintsPowerLevelData ;
};
struct OperatingConstraintsPowerLevelListDataSelectorsType {
	std::optional<PowerSequenceIdType> sequenceId ;
};
struct OperatingConstraintsResumeImplicationDataType {
	std::optional<PowerSequenceIdType> sequenceId ;
	std::optional<ScaledNumberType> resumeEnergyEstimated ;
	std::optional<UnitOfMeasurementType> energyUnit ;
	std::optional<ScaledNumberType> resumeCostEstimated ;
	std::optional<CurrencyType> currency ;
};
struct OperatingConstraintsResumeImplicationDataElementsType {
	std::optional<ElementTagType> sequenceId ;
	std::optional<ScaledNumberElementsType> resumeEnergyEstimated ;
	std::optional<ElementTagType> energyUnit ;
	std::optional<ScaledNumberElementsType> resumeCostEstimated ;
	std::optional<ElementTagType> currency ;
};
struct OperatingConstraintsResumeImplicationListDataType {
	std::optional<OperatingConstraintsResumeImplicationDataType> operatingConstraintsResumeImplicationData ;
};
struct OperatingConstraintsResumeImplicationListDataSelectorsType {
	std::optional<PowerSequenceIdType> sequenceId ;
};
struct SensingDataType {
	std::optional<AbsoluteOrRelativeTimeType> timestamp ;
	std::optional<SensingStateType> state ;
	std::optional<ScaledNumberType> value ;
};
struct SensingDataElementsType {
	std::optional<ElementTagType> timestamp ;
	std::optional<ElementTagType> state ;
	std::optional<ScaledNumberElementsType> value ;
};
struct SensingListDataType {
	std::optional<SensingDataType> sensingData ;
};
struct SensingListDataSelectorsType {
	std::optional<TimestampIntervalType> timestampInterval ;
};
struct SensingDescriptionDataType {
	std::optional<SensingTypeType> sensingType ;
	std::optional<UnitOfMeasurementType> unit ;
	std::optional<ScopeTypeType> scopeType ;
	std::optional<LabelType> label ;
	std::optional<DescriptionType> description ;
};
struct SensingDescriptionDataElementsType {
	std::optional<ElementTagType> sensingType ;
	std::optional<ElementTagType> unit ;
	std::optional<ElementTagType> scopeType ;
	std::optional<ElementTagType> label ;
	std::optional<ElementTagType> description ;
};
struct SmartEnergyManagementPsAlternativesRelationType {
	std::optional<AlternativesIdType> alternativesId ;
};
struct SmartEnergyManagementPsAlternativesType {
	std::optional<SmartEnergyManagementPsAlternativesRelationType> relation ;
	std::optional<SmartEnergyManagementPsPowerSequenceType> powerSequence ;
};
struct SmartEnergyManagementPsPowerSequenceType {
	std::optional<None> description ;
	std::optional<None> state ;
	std::optional<None> schedule ;
	std::optional<None> scheduleConstraints ;
	std::optional<None> schedulePreference ;
	std::optional<None> operatingConstraintsInterrupt ;
	std::optional<None> operatingConstraintsDuration ;
	std::optional<None> operatingConstraintsResumeImplication ;
	std::optional<SmartEnergyManagementPsPowerTimeSlotType> powerTimeSlot ;
};
struct SmartEnergyManagementPsPowerTimeSlotType {
	std::optional<None> schedule ;
	std::optional<SmartEnergyManagementPsPowerTimeSlotValueListType> valueList ;
	std::optional<None> scheduleConstraints ;
};
struct SmartEnergyManagementPsPowerTimeSlotValueListType {
	std::optional<None> value ;
};
struct SmartEnergyManagementPsDataType {
	std::optional<None> nodeScheduleInformation ;
	std::optional<SmartEnergyManagementPsAlternativesType> alternatives ;
};
struct SmartEnergyManagementPsAlternativesRelationElementsType {
	std::optional<ElementTagType> alternativesId ;
};
struct SmartEnergyManagementPsAlternativesElementsType {
	std::optional<SmartEnergyManagementPsAlternativesRelationElementsType> relation ;
	std::optional<SmartEnergyManagementPsPowerSequenceElementsType> powerSequence ;
};
struct SmartEnergyManagementPsPowerSequenceElementsType {
	std::optional<None> description ;
	std::optional<None> state ;
	std::optional<None> schedule ;
	std::optional<None> scheduleConstraints ;
	std::optional<None> schedulePreference ;
	std::optional<None> operatingConstraintsInterrupt ;
	std::optional<None> operatingConstraintsDuration ;
	std::optional<None> operatingConstraintsResumeImplication ;
	std::optional<SmartEnergyManagementPsPowerTimeSlotElementsType> powerTimeSlot ;
};
struct SmartEnergyManagementPsPowerTimeSlotElementsType {
	std::optional<None> schedule ;
	std::optional<SmartEnergyManagementPsPowerTimeSlotValueListElementsType> valueList ;
	std::optional<None> scheduleConstraints ;
};
struct SmartEnergyManagementPsPowerTimeSlotValueListElementsType {
	std::optional<None> value ;
};
struct SmartEnergyManagementPsDataElementsType {
	std::optional<None> nodeScheduleInformation ;
	std::optional<SmartEnergyManagementPsAlternativesElementsType> alternatives ;
};
struct SmartEnergyManagementPsDataSelectorsType {
	std::optional<None> alternativesRelation ;
	std::optional<None> powerSequenceDescription ;
	std::optional<None> powerTimeSlotSchedule ;
	std::optional<None> powerTimeSlotValue ;
};
struct SmartEnergyManagementPsPriceDataType {
	std::optional<None> price ;
};
struct SmartEnergyManagementPsPriceDataElementsType {
	std::optional<None> price ;
};
struct SmartEnergyManagementPsPriceDataSelectorsType {
	std::optional<None> price ;
};
struct SmartEnergyManagementPsConfigurationRequestCallType {
	std::optional<None> scheduleConfigurationRequest ;
};
struct SmartEnergyManagementPsConfigurationRequestCallElementsType {
	std::optional<None> scheduleConfigurationRequest ;
};
struct SmartEnergyManagementPsPriceCalculationRequestCallType {
	std::optional<None> priceCalculationRequest ;
};
struct SmartEnergyManagementPsPriceCalculationRequestCallElementsType {
	std::optional<None> priceCalculationRequest ;
};
struct StateInformationDataType {
	std::optional<stateInformationIdType> stateInformationId ;
	std::optional<StateInformationType> stateInformation ;
	std::optional<boolean> isActive ;
	std::optional<StateInformationCategoryType> category ;
	std::optional<AbsoluteOrRelativeTimeType> timeOfLastChange ;
};
struct StateInformationDataElementsType {
	std::optional<ElementTagType> stateInformationId ;
	std::optional<ElementTagType> stateInformation ;
	std::optional<ElementTagType> isActive ;
	std::optional<ElementTagType> category ;
	std::optional<ElementTagType> timeOfLastChange ;
};
struct StateInformationListDataType {
	std::optional<StateInformationDataType> stateInformationData ;
};
struct StateInformationListDataSelectorsType {
	std::optional<stateInformationIdType> stateInformationId ;
	std::optional<StateInformationType> stateInformation ;
	std::optional<boolean> isActive ;
	std::optional<StateInformationCategoryType> category ;
};
struct SupplyConditionDataType {
	std::optional<ConditionIdType> conditionId ;
	std::optional<AbsoluteOrRelativeTimeType> timestamp ;
	std::optional<SupplyConditionEventTypeType> eventType ;
	std::optional<SupplyConditionOriginatorType> originator ;
	std::optional<ThresholdIdType> thresholdId ;
	std::optional<ScaledNumberType> thresholdPercentage ;
	std::optional<TimePeriodType> relevantPeriod ;
	std::optional<DescriptionType> description ;
	std::optional<GridConditionType> gridCondition ;
};
struct SupplyConditionDataElementsType {
	std::optional<ElementTagType> conditionId ;
	std::optional<ElementTagType> timestamp ;
	std::optional<ElementTagType> eventType ;
	std::optional<ElementTagType> originator ;
	std::optional<ElementTagType> thresholdId ;
	std::optional<ScaledNumberElementsType> thresholdPercentage ;
	std::optional<TimePeriodElementsType> relevantPeriod ;
	std::optional<ElementTagType> description ;
	std::optional<ElementTagType> gridCondition ;
};
struct SupplyConditionListDataType {
	std::optional<SupplyConditionDataType> supplyConditionData ;
};
struct SupplyConditionListDataSelectorsType {
	std::optional<ConditionIdType> conditionId ;
	std::optional<TimestampIntervalType> timestampInterval ;
	std::optional<SupplyConditionEventTypeType> eventType ;
	std::optional<SupplyConditionOriginatorType> originator ;
};
struct SupplyConditionDescriptionDataType {
	std::optional<ConditionIdType> conditionId ;
	std::optional<CommodityTypeType> commodityType ;
	std::optional<EnergyDirectionType> positiveEnergyDirection ;
	std::optional<LabelType> label ;
	std::optional<DescriptionType> description ;
};
struct SupplyConditionDescriptionDataElementsType {
	std::optional<ElementTagType> conditionId ;
	std::optional<ElementTagType> commodityType ;
	std::optional<ElementTagType> positiveEnergyDirection ;
	std::optional<ElementTagType> label ;
	std::optional<ElementTagType> description ;
};
struct SupplyConditionDescriptionListDataType {
	std::optional<SupplyConditionDescriptionDataType> supplyConditionDescriptionData ;
};
struct SupplyConditionDescriptionListDataSelectorsType {
	std::optional<ConditionIdType> conditionId ;
};
struct SupplyConditionThresholdRelationDataType {
	std::optional<ConditionIdType> conditionId ;
	std::optional<ThresholdIdType> thresholdId ;
};
struct SupplyConditionThresholdRelationDataElementsType {
	std::optional<ElementTagType> conditionId ;
	std::optional<ElementTagType> thresholdId ;
};
struct SupplyConditionThresholdRelationListDataType {
	std::optional<SupplyConditionThresholdRelationDataType> supplyConditionThresholdRelationData ;
};
struct SupplyConditionThresholdRelationListDataSelectorsType {
	std::optional<ConditionIdType> conditionId ;
	std::optional<ThresholdIdType> thresholdId ;
};
struct TaskManagementDirectControlRelatedType {
};
struct TaskManagementDirectControlRelatedElementsType {
};
struct TaskManagementHvacRelatedType {
	std::optional<HvacOverrunIdType> overrunId ;
};
struct TaskManagementHvacRelatedElementsType {
	std::optional<ElementTagType> overrunId ;
};
struct TaskManagementLoadControlReleatedType {
	std::optional<LoadControlEventIdType> eventId ;
};
struct TaskManagementLoadControlReleatedElementsType {
	std::optional<ElementTagType> eventId ;
};
struct TaskManagementPowerSequencesRelatedType {
	std::optional<PowerSequenceIdType> sequenceId ;
};
struct TaskManagementPowerSequencesRelatedElementsType {
	std::optional<ElementTagType> sequenceId ;
};
struct TaskManagementSmartEnergyManagementPsRelatedType {
	std::optional<PowerSequenceIdType> sequenceId ;
};
struct TaskManagementSmartEnergyManagementPsRelatedElementsType {
	std::optional<ElementTagType> sequenceId ;
};
struct TaskManagementJobDataType {
	std::optional<TaskManagementJobIdType> jobId ;
	std::optional<AbsoluteOrRelativeTimeType> timestamp ;
	std::optional<TaskManagementJobStateType> jobState ;
	std::optional<duration> elapsedTime ;
	std::optional<duration> remainingTime ;
};
struct TaskManagementJobDataElementsType {
	std::optional<ElementTagType> jobId ;
	std::optional<ElementTagType> timestamp ;
	std::optional<ElementTagType> jobState ;
	std::optional<ElementTagType> elapsedTime ;
	std::optional<ElementTagType> remainingTime ;
};
struct TaskManagementJobListDataType {
	std::optional<TaskManagementJobDataType> taskManagementJobData ;
};
struct TaskManagementJobListDataSelectorsType {
	std::optional<TaskManagementJobIdType> jobId ;
	std::optional<TaskManagementJobStateType> jobState ;
};
struct TaskManagementJobRelationDataType {
	std::optional<TaskManagementJobIdType> jobId ;
	std::optional<TaskManagementDirectControlRelatedType> directControlRelated ;
	std::optional<TaskManagementHvacRelatedType> hvacRelated ;
	std::optional<TaskManagementLoadControlReleatedType> loadControlReleated ;
	std::optional<TaskManagementPowerSequencesRelatedType> powerSequencesRelated ;
	std::optional<TaskManagementSmartEnergyManagementPsRelatedType> smartEnergyManagementPsRelated ;
};
struct TaskManagementJobRelationDataElementsType {
	std::optional<ElementTagType> jobId ;
	std::optional<TaskManagementDirectControlRelatedElementsType> directControlRelated ;
	std::optional<TaskManagementHvacRelatedElementsType> hvacRelated ;
	std::optional<TaskManagementLoadControlReleatedElementsType> loadControlReleated ;
	std::optional<TaskManagementPowerSequencesRelatedElementsType> powerSequencesRelated ;
	std::optional<TaskManagementSmartEnergyManagementPsRelatedElementsType> smartEnergyManagementPsRelated ;
};
struct TaskManagementJobRelationListDataType {
	std::optional<TaskManagementJobRelationDataType> taskManagementJobRelationData ;
};
struct TaskManagementJobRelationListDataSelectorsType {
	std::optional<TaskManagementJobIdType> jobId ;
};
struct TaskManagementJobDescriptionDataType {
	std::optional<TaskManagementJobIdType> jobId ;
	std::optional<TaskManagementJobSourceType> jobSource ;
	std::optional<LabelType> label ;
	std::optional<DescriptionType> description ;
};
struct TaskManagementJobDescriptionDataElementsType {
	std::optional<ElementTagType> jobId ;
	std::optional<ElementTagType> jobSource ;
	std::optional<ElementTagType> label ;
	std::optional<ElementTagType> description ;
};
struct TaskManagementJobDescriptionListDataType {
	std::optional<TaskManagementJobDescriptionDataType> taskManagementJobDescriptionData ;
};
struct TaskManagementJobDescriptionListDataSelectorsType {
	std::optional<TaskManagementJobIdType> jobId ;
	std::optional<TaskManagementJobSourceType> jobSource ;
};
struct TaskManagementOverviewDataType {
	std::optional<boolean> remoteControllable ;
	std::optional<boolean> jobsActive ;
};
struct TaskManagementOverviewDataElementsType {
	std::optional<ElementTagType> remoteControllable ;
	std::optional<ElementTagType> jobsActive ;
};
struct TimeInformationDataType {
	std::optional<dateTime> utc ;
	std::optional<duration> utcOffset ;
	std::optional<DayOfWeekType> dayOfWeek ;
	std::optional<CalendarWeekType> calendarWeek ;
};
struct TimeInformationDataElementsType {
	std::optional<ElementTagType> utc ;
	std::optional<ElementTagType> utcOffset ;
	std::optional<ElementTagType> dayOfWeek ;
	std::optional<ElementTagType> calendarWeek ;
};
struct TimeDistributorDataType {
	std::optional<boolean> isTimeDistributor ;
	std::optional<unsignedInt> distributorPriority ;
};
struct TimeDistributorDataElementsType {
	std::optional<ElementTagType> isTimeDistributor ;
	std::optional<ElementTagType> distributorPriority ;
};
struct TimePrecisionDataType {
	std::optional<boolean> isSynchronised ;
	std::optional<dateTime> lastSyncAt ;
	std::optional<integer> clockDrift ;
};
struct TimePrecisionDataElementsType {
	std::optional<ElementTagType> isSynchronised ;
	std::optional<ElementTagType> lastSyncAt ;
	std::optional<ElementTagType> clockDrift ;
};
struct TimeDistributorEnquiryCallType {
};
struct TimeDistributorEnquiryCallElementsType {
};
struct HeaderType {
	std::optional<SpecificationVersionType> specificationVersion ;
	std::optional<FeatureAddressType> addressSource ;
	std::optional<FeatureAddressType> addressDestination ;
	std::optional<FeatureAddressType> addressOriginator ;
	std::optional<MsgCounterType> msgCounter ;
	std::optional<MsgCounterType> msgCounterReference ;
	std::optional<CmdClassifierType> cmdClassifier ;
	std::optional<boolean> ackRequest ;
	std::optional<AbsoluteOrRelativeTimeType> timestamp ;
};
struct PayloadType {
	std::optional<CmdType> cmd ;
};
struct DatagramType {
	std::optional<HeaderType> header ;
	std::optional<PayloadType> payload ;
};
