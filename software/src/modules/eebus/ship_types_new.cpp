
// This file is generated by generator.py. Changes will be overwritten
#include "ship_types_new.h"
bool convertToJson(const ConnectionHelloPhaseType &src, JsonVariant& dst) {
	String enumName;
	switch(src) {
	case ConnectionHelloPhaseType::pending:
		 enumName = "pending";
		break;
	case ConnectionHelloPhaseType::ready:
		 enumName = "ready";
		break;
	case ConnectionHelloPhaseType::aborted:
		 enumName = "aborted";
		break;
	} 
	return dst.set(enumName);
}
void convertFromJson(const JsonVariantConst& src, ConnectionHelloPhaseType &dst) {
	if (src == "pending") {
		dst = ConnectionHelloPhaseType::pending;
		return;
	}
	if (src == "ready") {
		dst = ConnectionHelloPhaseType::ready;
		return;
	}
	if (src == "aborted") {
		dst = ConnectionHelloPhaseType::aborted;
		return;
	}
	 return;
}
bool convertToJson(const ProtocolHandshakeTypeType &src, JsonVariant& dst) {
	String enumName;
	switch(src) {
	case ProtocolHandshakeTypeType::announceMax:
		 enumName = "announceMax";
		break;
	case ProtocolHandshakeTypeType::select:
		 enumName = "select";
		break;
	} 
	return dst.set(enumName);
}
void convertFromJson(const JsonVariantConst& src, ProtocolHandshakeTypeType &dst) {
	if (src == "announceMax") {
		dst = ProtocolHandshakeTypeType::announceMax;
		return;
	}
	if (src == "select") {
		dst = ProtocolHandshakeTypeType::select;
		return;
	}
	 return;
}
bool convertToJson(const PinStateType &src, JsonVariant& dst) {
	String enumName;
	switch(src) {
	case PinStateType::required:
		 enumName = "required";
		break;
	case PinStateType::optional:
		 enumName = "optional";
		break;
	case PinStateType::pinOk:
		 enumName = "pinOk";
		break;
	case PinStateType::none:
		 enumName = "none";
		break;
	} 
	return dst.set(enumName);
}
void convertFromJson(const JsonVariantConst& src, PinStateType &dst) {
	if (src == "required") {
		dst = PinStateType::required;
		return;
	}
	if (src == "optional") {
		dst = PinStateType::optional;
		return;
	}
	if (src == "pinOk") {
		dst = PinStateType::pinOk;
		return;
	}
	if (src == "none") {
		dst = PinStateType::none;
		return;
	}
	 return;
}
bool convertToJson(const PinInputPermissionType &src, JsonVariant& dst) {
	String enumName;
	switch(src) {
	case PinInputPermissionType::busy:
		 enumName = "busy";
		break;
	case PinInputPermissionType::ok:
		 enumName = "ok";
		break;
	} 
	return dst.set(enumName);
}
void convertFromJson(const JsonVariantConst& src, PinInputPermissionType &dst) {
	if (src == "busy") {
		dst = PinInputPermissionType::busy;
		return;
	}
	if (src == "ok") {
		dst = PinInputPermissionType::ok;
		return;
	}
	 return;
}
bool convertToJson(const ConnectionClosePhaseType &src, JsonVariant& dst) {
	String enumName;
	switch(src) {
	case ConnectionClosePhaseType::announce:
		 enumName = "announce";
		break;
	case ConnectionClosePhaseType::confirm:
		 enumName = "confirm";
		break;
	} 
	return dst.set(enumName);
}
void convertFromJson(const JsonVariantConst& src, ConnectionClosePhaseType &dst) {
	if (src == "announce") {
		dst = ConnectionClosePhaseType::announce;
		return;
	}
	if (src == "confirm") {
		dst = ConnectionClosePhaseType::confirm;
		return;
	}
	 return;
}
bool convertToJson(const ConnectionCloseReasonType &src, JsonVariant& dst) {
	String enumName;
	switch(src) {
	case ConnectionCloseReasonType::unspecific:
		 enumName = "unspecific";
		break;
	case ConnectionCloseReasonType::removedConnection:
		 enumName = "removedConnection";
		break;
	} 
	return dst.set(enumName);
}
void convertFromJson(const JsonVariantConst& src, ConnectionCloseReasonType &dst) {
	if (src == "unspecific") {
		dst = ConnectionCloseReasonType::unspecific;
		return;
	}
	if (src == "removedConnection") {
		dst = ConnectionCloseReasonType::removedConnection;
		return;
	}
	 return;
}
bool convertToJson(const ConnectionHelloType &src, JsonVariant& dst) {
	if (src.phase) {
		dst["phase"] = *src.phase;
	}
	if (src.waiting) {
		dst["waiting"] = *src.waiting;
	}
	if (src.prolongationRequest) {
		dst["prolongationRequest"] = *src.prolongationRequest;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, ConnectionHelloType &dst) {
	if (src.is<JsonArrayConst>()) {
		JsonArrayConst array = src.as<JsonArrayConst>();
		for (JsonVariantConst item : array) {	if (item["phase"]) {
		dst.phase = item["phase"].as<decltype(dst.phase)::value_type>();
	} else {
		//dst.phase = std::nullopt;
	}
	if (item["waiting"]) {
		dst.waiting = item["waiting"].as<decltype(dst.waiting)::value_type>();
	} else {
		//dst.waiting = std::nullopt;
	}
	if (item["prolongationRequest"]) {
		dst.prolongationRequest = item["prolongationRequest"].as<decltype(dst.prolongationRequest)::value_type>();
	} else {
		//dst.prolongationRequest = std::nullopt;
	}

		}
	} else {
			if (src["phase"]) {
		dst.phase = src["phase"].as<decltype(dst.phase)::value_type>();
	} else {
		//dst.phase = std::nullopt;
	}
	if (src["waiting"]) {
		dst.waiting = src["waiting"].as<decltype(dst.waiting)::value_type>();
	} else {
		//dst.waiting = std::nullopt;
	}
	if (src["prolongationRequest"]) {
		dst.prolongationRequest = src["prolongationRequest"].as<decltype(dst.prolongationRequest)::value_type>();
	} else {
		//dst.prolongationRequest = std::nullopt;
	}

	}

}
bool convertToJson(const MessageProtocolFormatsType &src, JsonVariant& dst) {
	if (src.format) {
		dst["format"] = *src.format;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, MessageProtocolFormatsType &dst) {
	if (src.is<JsonArrayConst>()) {
		JsonArrayConst array = src.as<JsonArrayConst>();
		for (JsonVariantConst item : array) {	if (item["format"]) {
		dst.format = item["format"].as<decltype(dst.format)::value_type>();
	} else {
		//dst.format = std::nullopt;
	}

		}
	} else {
			if (src["format"]) {
		dst.format = src["format"].as<decltype(dst.format)::value_type>();
	} else {
		//dst.format = std::nullopt;
	}

	}

}
bool convertToJson(const MessageProtocolHandshakeType &src, JsonVariant& dst) {
	if (src.handshakeType) {
		dst["handshakeType"] = *src.handshakeType;
	}
	if (src.major) {
		dst["major"] = *src.major;
	}
	if (src.minor) {
		dst["minor"] = *src.minor;
	}
	if (src.formats) {
		dst["formats"] = *src.formats;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, MessageProtocolHandshakeType &dst) {
	if (src.is<JsonArrayConst>()) {
		JsonArrayConst array = src.as<JsonArrayConst>();
		for (JsonVariantConst item : array) {	if (item["handshakeType"]) {
		dst.handshakeType = item["handshakeType"].as<decltype(dst.handshakeType)::value_type>();
	} else {
		//dst.handshakeType = std::nullopt;
	}
	if (item["major"]) {
		dst.major = item["major"].as<decltype(dst.major)::value_type>();
	} else {
		//dst.major = std::nullopt;
	}
	if (item["minor"]) {
		dst.minor = item["minor"].as<decltype(dst.minor)::value_type>();
	} else {
		//dst.minor = std::nullopt;
	}
	if (item["formats"]) {
		dst.formats = item["formats"].as<decltype(dst.formats)::value_type>();
	} else {
		//dst.formats = std::nullopt;
	}

		}
	} else {
			if (src["handshakeType"]) {
		dst.handshakeType = src["handshakeType"].as<decltype(dst.handshakeType)::value_type>();
	} else {
		//dst.handshakeType = std::nullopt;
	}
	if (src["major"]) {
		dst.major = src["major"].as<decltype(dst.major)::value_type>();
	} else {
		//dst.major = std::nullopt;
	}
	if (src["minor"]) {
		dst.minor = src["minor"].as<decltype(dst.minor)::value_type>();
	} else {
		//dst.minor = std::nullopt;
	}
	if (src["formats"]) {
		dst.formats = src["formats"].as<decltype(dst.formats)::value_type>();
	} else {
		//dst.formats = std::nullopt;
	}

	}

}
bool convertToJson(const MessageProtocolHandshakeErrorType &src, JsonVariant& dst) {
	if (src.error) {
		dst["error"] = *src.error;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, MessageProtocolHandshakeErrorType &dst) {
	if (src.is<JsonArrayConst>()) {
		JsonArrayConst array = src.as<JsonArrayConst>();
		for (JsonVariantConst item : array) {	if (item["error"]) {
		dst.error = item["error"].as<decltype(dst.error)::value_type>();
	} else {
		//dst.error = std::nullopt;
	}

		}
	} else {
			if (src["error"]) {
		dst.error = src["error"].as<decltype(dst.error)::value_type>();
	} else {
		//dst.error = std::nullopt;
	}

	}

}
bool convertToJson(const ConnectionPinStateType &src, JsonVariant& dst) {
	if (src.pinState) {
		dst["pinState"] = *src.pinState;
	}
	if (src.inputPermission) {
		dst["inputPermission"] = *src.inputPermission;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, ConnectionPinStateType &dst) {
	if (src.is<JsonArrayConst>()) {
		JsonArrayConst array = src.as<JsonArrayConst>();
		for (JsonVariantConst item : array) {	if (item["pinState"]) {
		dst.pinState = item["pinState"].as<decltype(dst.pinState)::value_type>();
	} else {
		//dst.pinState = std::nullopt;
	}
	if (item["inputPermission"]) {
		dst.inputPermission = item["inputPermission"].as<decltype(dst.inputPermission)::value_type>();
	} else {
		//dst.inputPermission = std::nullopt;
	}

		}
	} else {
			if (src["pinState"]) {
		dst.pinState = src["pinState"].as<decltype(dst.pinState)::value_type>();
	} else {
		//dst.pinState = std::nullopt;
	}
	if (src["inputPermission"]) {
		dst.inputPermission = src["inputPermission"].as<decltype(dst.inputPermission)::value_type>();
	} else {
		//dst.inputPermission = std::nullopt;
	}

	}

}
bool convertToJson(const ConnectionPinInputType &src, JsonVariant& dst) {
	if (src.pin) {
		dst["pin"] = *src.pin;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, ConnectionPinInputType &dst) {
	if (src.is<JsonArrayConst>()) {
		JsonArrayConst array = src.as<JsonArrayConst>();
		for (JsonVariantConst item : array) {	if (item["pin"]) {
		dst.pin = item["pin"].as<decltype(dst.pin)::value_type>();
	} else {
		//dst.pin = std::nullopt;
	}

		}
	} else {
			if (src["pin"]) {
		dst.pin = src["pin"].as<decltype(dst.pin)::value_type>();
	} else {
		//dst.pin = std::nullopt;
	}

	}

}
bool convertToJson(const ConnectionPinErrorType &src, JsonVariant& dst) {
	if (src.error) {
		dst["error"] = *src.error;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, ConnectionPinErrorType &dst) {
	if (src.is<JsonArrayConst>()) {
		JsonArrayConst array = src.as<JsonArrayConst>();
		for (JsonVariantConst item : array) {	if (item["error"]) {
		dst.error = item["error"].as<decltype(dst.error)::value_type>();
	} else {
		//dst.error = std::nullopt;
	}

		}
	} else {
			if (src["error"]) {
		dst.error = src["error"].as<decltype(dst.error)::value_type>();
	} else {
		//dst.error = std::nullopt;
	}

	}

}
bool convertToJson(const SpineHeaderType &src, JsonVariant& dst) {
	if (src.protocolId) {
		dst["protocolId"] = *src.protocolId;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, SpineHeaderType &dst) {
	if (src.is<JsonArrayConst>()) {
		JsonArrayConst array = src.as<JsonArrayConst>();
		for (JsonVariantConst item : array) {	if (item["protocolId"]) {
		dst.protocolId = item["protocolId"].as<decltype(dst.protocolId)::value_type>();
	} else {
		//dst.protocolId = std::nullopt;
	}

		}
	} else {
			if (src["protocolId"]) {
		dst.protocolId = src["protocolId"].as<decltype(dst.protocolId)::value_type>();
	} else {
		//dst.protocolId = std::nullopt;
	}

	}

}
bool convertToJson(const ExtensionType &src, JsonVariant& dst) {
	if (src.extensionId) {
		dst["extensionId"] = *src.extensionId;
	}
	if (src.binary) {
		dst["binary"] = *src.binary;
	}
	if (src.string) {
		dst["string"] = *src.string;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, ExtensionType &dst) {
	if (src.is<JsonArrayConst>()) {
		JsonArrayConst array = src.as<JsonArrayConst>();
		for (JsonVariantConst item : array) {	if (item["extensionId"]) {
		dst.extensionId = item["extensionId"].as<decltype(dst.extensionId)::value_type>();
	} else {
		//dst.extensionId = std::nullopt;
	}
	if (item["binary"]) {
		dst.binary = item["binary"].as<decltype(dst.binary)::value_type>();
	} else {
		//dst.binary = std::nullopt;
	}
	if (item["string"]) {
		dst.string = item["string"].as<decltype(dst.string)::value_type>();
	} else {
		//dst.string = std::nullopt;
	}

		}
	} else {
			if (src["extensionId"]) {
		dst.extensionId = src["extensionId"].as<decltype(dst.extensionId)::value_type>();
	} else {
		//dst.extensionId = std::nullopt;
	}
	if (src["binary"]) {
		dst.binary = src["binary"].as<decltype(dst.binary)::value_type>();
	} else {
		//dst.binary = std::nullopt;
	}
	if (src["string"]) {
		dst.string = src["string"].as<decltype(dst.string)::value_type>();
	} else {
		//dst.string = std::nullopt;
	}

	}

}
bool convertToJson(const DataType &src, JsonVariant& dst) {
	if (src.header) {
		dst["header"] = *src.header;
	}
	if (src.payload) {
		dst["payload"] = *src.payload;
	}
	if (src.extension) {
		dst["extension"] = *src.extension;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, DataType &dst) {
	if (src.is<JsonArrayConst>()) {
		JsonArrayConst array = src.as<JsonArrayConst>();
		for (JsonVariantConst item : array) {	if (item["header"]) {
		dst.header = item["header"].as<decltype(dst.header)::value_type>();
	} else {
		//dst.header = std::nullopt;
	}
	if (item["payload"]) {
		dst.payload = item["payload"].as<decltype(dst.payload)::value_type>();
	} else {
		//dst.payload = std::nullopt;
	}
	if (item["extension"]) {
		dst.extension = item["extension"].as<decltype(dst.extension)::value_type>();
	} else {
		//dst.extension = std::nullopt;
	}

		}
	} else {
			if (src["header"]) {
		dst.header = src["header"].as<decltype(dst.header)::value_type>();
	} else {
		//dst.header = std::nullopt;
	}
	if (src["payload"]) {
		dst.payload = src["payload"].as<decltype(dst.payload)::value_type>();
	} else {
		//dst.payload = std::nullopt;
	}
	if (src["extension"]) {
		dst.extension = src["extension"].as<decltype(dst.extension)::value_type>();
	} else {
		//dst.extension = std::nullopt;
	}

	}

}
bool convertToJson(const ConnectionCloseType &src, JsonVariant& dst) {
	if (src.phase) {
		dst["phase"] = *src.phase;
	}
	if (src.maxTime) {
		dst["maxTime"] = *src.maxTime;
	}
	if (src.reason) {
		dst["reason"] = *src.reason;
	}

	return true;
}
void convertFromJson(const JsonVariantConst& src, ConnectionCloseType &dst) {
	if (src.is<JsonArrayConst>()) {
		JsonArrayConst array = src.as<JsonArrayConst>();
		for (JsonVariantConst item : array) {	if (item["phase"]) {
		dst.phase = item["phase"].as<decltype(dst.phase)::value_type>();
	} else {
		//dst.phase = std::nullopt;
	}
	if (item["maxTime"]) {
		dst.maxTime = item["maxTime"].as<decltype(dst.maxTime)::value_type>();
	} else {
		//dst.maxTime = std::nullopt;
	}
	if (item["reason"]) {
		dst.reason = item["reason"].as<decltype(dst.reason)::value_type>();
	} else {
		//dst.reason = std::nullopt;
	}

		}
	} else {
			if (src["phase"]) {
		dst.phase = src["phase"].as<decltype(dst.phase)::value_type>();
	} else {
		//dst.phase = std::nullopt;
	}
	if (src["maxTime"]) {
		dst.maxTime = src["maxTime"].as<decltype(dst.maxTime)::value_type>();
	} else {
		//dst.maxTime = std::nullopt;
	}
	if (src["reason"]) {
		dst.reason = src["reason"].as<decltype(dst.reason)::value_type>();
	} else {
		//dst.reason = std::nullopt;
	}

	}

}
bool convertToJson(const AccessMethodsRequestType &src, JsonVariant& dst) {

	return true;
}
void convertFromJson(const JsonVariantConst& src, AccessMethodsRequestType &dst) {

}
