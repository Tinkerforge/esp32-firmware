__copyright__ = """ esp32-firmware
Copyright (C) 2025 Julius Dill <julius@tinkerforge.com>

This library is free software; you can redistribute it and/or
modify it under the terms of the GNU Lesser General Public
License as published by the Free Software Foundation; either
version 2 of the License, or (at your option) any later version.

This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public
License along with this library; if not, write to the
Free Software Foundation, Inc., 59 Temple Place - Suite 330,
Boston, MA 02111-1307, USA.

"""

import argparse
import xmlschema
import os
import re


GENERATE_DEFAULT_CONSTRUCTOR = False

spine_cpp_header_header = """
// This file is generated by generator.py. Changes will be overwritten

#pragma once

#include "module.h"
#include "config.h"
#include <string>
#include <vector>
#include <optional>

namespace ArduinoJson
{
template <typename T> struct Converter<std::vector<T>>
{
    static void toJson(const std::vector<T> &src, JsonVariant dst);
    static std::vector<T> fromJson(JsonVariantConst src);
    static bool checkJson(JsonVariantConst src);
};
} // namespace ArduinoJson

/**
 * An alternative optional implementation that automatically fills itself if needed.
 * @tparam T The typename of the optional value.
 */
template <typename T>
class SpineOptional
{
    mutable T value{};
    mutable bool is_set = false;

public:
    using value_type = T;
    SpineOptional() = default;
    SpineOptional(const SpineOptional&) = default;
    SpineOptional(SpineOptional&&) noexcept = default;
    SpineOptional& operator=(const SpineOptional&) = default;
    SpineOptional& operator=(SpineOptional&&) noexcept = default;
    

    SpineOptional(const T &v) : value(v), is_set(true)
    {
    }

    /**
     * Assign value to the optional and mark it as set.
     * @param v the value assigned
     * @return
     */
    SpineOptional &operator=(const T &v)
    {
        value = v;
        is_set = true;
        return *this;
    }

    explicit operator bool() const noexcept
    {
        return is_set;
    }

    /**
     *
     * @return The value contained in the optional.
     */
    T &operator*()
    {
        return value;
    }

    /**
     *
     * @return The value contained in the optional.
     */
    const T &operator*() const
    {
        return value;
    }

    /**
     *
     * @return The pointer to the value contained in the optional. If the optional is not set, it will be default constructed and set.
     */
    T *operator->()
    {
        if (!is_set) {
            value = T{};
        }
        is_set = true;
        return &value;
    }

    /**
     *
     * @return The pointer to the value contained in the optional. If the optional is not set, it will be default constructed and set.
     */
    const T *operator->() const
    {
        if (!is_set) {
            value = T{};
        }
        is_set = true;
        return &value;
    }

    T &get()
    {
        is_set = true;
        return value;
    }

    const T &get() const
    {
        is_set = true;
        return value;
    }

    bool has_value() const
    {
        return is_set;
    }

    /**
     * Resets the optional to an unset state and clears the value.
     */
    void reset()
    {
        is_set = false;
        value = T{};
    }

    bool isNull() const
    {
        return !is_set;
    }

    /**
     * Resets the optional to a set state and default constructs the value.
     */
    void emplace()
    {
        is_set = true;
        value = T{};
    }

    friend bool operator==(const SpineOptional<T> &opt, const T &v)
    {
        return opt.is_set && opt.value == v;
    }

    friend bool operator==(const T &v, const SpineOptional<T> &opt)
    {
        return opt.is_set && opt.value == v;
    }

    friend bool operator!=(const SpineOptional<T> &opt, const T &v)
    {
        return !(opt == v);
    }

    friend bool operator!=(const T &v, const SpineOptional<T> &opt)
    {
        return !(v == opt);
    }
};

struct DateTimeStruct
{
    // Added manually
    SpineOptional<uint16_t> year;
    SpineOptional<uint8_t> month;
    SpineOptional<uint8_t> day;
    SpineOptional<uint8_t> hour;
    SpineOptional<uint8_t> minute;
    SpineOptional<uint8_t> second;
    SpineOptional<uint16_t> millisecond;
    SpineOptional<int8_t> timezone; // Offset from UTC in hours, 0 if time is UTC, empty if no TZ is given
};
"""

spine_cpp_implementation_header = """
// This file is generated by generator.py. Changes will be overwritten
#include "spine_types.h"
#include "event_log_prefix.h"
#include "module_dependencies.h"


namespace ArduinoJson
{
template <typename T>
void Converter<std::vector<T>>::toJson(const std::vector<T> &src, JsonVariant dst)
{
    JsonArray array = dst.to<JsonArray>();
    for (T item : src)
        array.add(item);
}

template <typename T>
std::vector<T> Converter<std::vector<T>>::fromJson(JsonVariantConst src)
{
    std::vector<T> dst;
    for (T item : src.as<JsonArrayConst>())
        dst.push_back(item);    
    return dst;
}

template <typename T>
bool Converter<std::vector<T>>::checkJson(JsonVariantConst src)
{
    JsonArrayConst array = src;
    bool result = array;
    for (JsonVariantConst item : array)
        result &= item.is<T>();
    return result;
}


} // namespace ArduinoJson
"""

ship_cpp_header_header = """
// This file is generated by generator.py. Changes will be overwritten
#pragma once
#include "module.h"
#include "config.h"
#include <string>
#include <vector>
#include <optional>
#include "spine_types.h"
"""

ship_cpp_implementation_header = """
// This file is generated by generator.py. Changes will be overwritten
#include "ship_types_new.h"
"""

unprocessed_elements = 0


class Spine_type:
    # @brief: Type_name: either "define", "using", "enum", "struct" or "class"
    type_name = ""
    depends_on = []
    name = ""
    code = ""
    to_json_code = ""
    from_json_code = ""
    upper_limit = None
    lower_limit = None
    # this is technically required but we dont check it
    regex_restriction = None

    def __init__(self, type_name, name, code):
        self.type_name = type_name
        self.name = name
        self.code = code
        self.depends_on = []


cpp_datatypes: list[Spine_type] = []

# This maps SPINE Functions to the datatypes
type_function_mapping: list[tuple[str, str]] = []


def remove_namespace(name):
    if name is not None:
        if "}" in name:
            return name.split("}", 1)[1]  # Entfernt den Namespace-URI
    else:
        return "None"
    return name


def to_cpp_datatype(type_name):
    # type_name = str(type_name.__name__)
    if hasattr(type_name, "__name__"):
        type_name_str = str(type_name.__name__)
    else:
        type_name_str = type_name
    type_mapping = {
        "string": "std::string",
        "str": "std::string",
        "int": "int",
        "integer": "int",
        "float": "float",
        "double": "double",
        "boolean": "bool",
        "bool": "bool",
        "duration": "std::string",  # For now we push all these into strings and handle them later
        "datetime10": "std::string",
        "datetime": "std::string",
        "date": "std::string",
        "time": "std::string",
        "anytype": "std::string",  # This is a catch-all for any type that is not defined
        "unsignedshort": "uint16_t",
        "unsignedint": "uint32_t",
        "unsignedbyte": "uint8_t",
        "unsignedlong": "uint64_t",
        "hexbinary": "std::string",  # this might be better to convert to byte array
    }
    # if type_name not in type_mapping:
    #       print("Unknown datatype:", type_name)
    return type_mapping.get(type_name_str.lower(), type_name)


def remove_duplicate_objects(spine_types: list[Spine_type]):
    seen = set()
    result = []
    for spine_type in spine_types:
        if spine_type.name not in seen:
            seen.add(spine_type.name)
            result.append(spine_type)
    return result


def remove_duplicate_function_mappings(type_function_mapping: list[tuple[str, str]]):
    seen = set()
    result = []
    for mapping in type_function_mapping:
        if mapping not in seen:
            seen.add(mapping)
            result.append(mapping)
    return result


def sort_and_resolve_dependencies(spine_types: list[Spine_type]):
    type_order = {"define": 0, "using": 1, "enum": 2, "struct": 3, "class": 4}

    dependency_map = {datatype_l.name: datatype_l.depends_on for datatype_l in cpp_datatypes}

    sorted_datatypes = []
    visited = set()

    def visit(datatype_v):
        if datatype_v.name in visited:
            return
        visited.add(datatype_v.name)
        for dependency in dependency_map.get(datatype_v.name, []):
            dependent_datatype = next((d for d in cpp_datatypes if d.name == dependency), None)
            if dependent_datatype:
                visit(dependent_datatype)
        sorted_datatypes.append(datatype_v)

    cpp_datatypes.sort(key=lambda x: type_order.get(x.type_name, 5))
    for datatype_l in cpp_datatypes:
        visit(datatype_l)

    return sorted_datatypes


def make_variable_name(name: str):
    forbidden_names = ["switch", "auto", "SAR", "delete"]
    # Cleanup the variable so it can be used in C++
    name = ''.join(char if char.isalnum() else '_' for char in name)
    # Stelle sicher, dass der Name mit einem Buchstaben beginnt
    if not name[0].isalpha() or name[0] in forbidden_names or name in forbidden_names:
        name = 'var_' + name
    return name


def process_complex_type(complex_type):
    global unprocessed_elements
    struct_type_name = remove_namespace(complex_type.name)
    # we dont generate cmdtype and datagramtype. They are handled differently
    if struct_type_name == "CmdType" or struct_type_name == "DatagramType" or struct_type_name == "PayloadType":
        return
    new_type = Spine_type("struct", struct_type_name, "")
    if hasattr(complex_type.content, "content_type_label") and complex_type.content.content_type_label == "simple":
        new_type = Spine_type("using", remove_namespace(complex_type.name), "")
        new_type.code = "using " + remove_namespace(complex_type.name) + " = " + to_cpp_datatype(
            complex_type.base_type.python_type) + "; \n"
        cpp_datatypes.append(new_type)
        return
    elif complex_type.content.model == "sequence":
        sequence_size = len(complex_type.content)
        elements = []
        new_type.code = f"/**\n * Datatype {struct_type_name} as defined in {complex_type.schema.name}\n*/\nstruct {struct_type_name} {{ \n"
        new_type.to_json_code = f"""bool convertToJson(const {struct_type_name} &src, JsonVariant& dst) {{\n\tif (!dst.to<JsonObject>()) {{return false;}}\n"""

        #new_type.from_json_code = f"""void convertFromJson(const JsonVariantConst& src, {struct_type_name} &dst) {{\n"""
        for elem in complex_type.content:
            variable_type = variable_name = ""
            is_vec = False
            if hasattr(elem, "model"):
                if elem.model == "sequence":
                    if len(elem) > 0:
                        for sub_elem in elem:
                            if len(sub_elem) == 1:
                                sub_elem = sub_elem[0]
                            elif len(sub_elem) > 1:
                                print("Sub element too long")
                            is_vec = sub_elem.max_occurs != 1
                            variable_name = make_variable_name(remove_namespace(sub_elem.name))
                            if not hasattr(sub_elem, "type") and hasattr(sub_elem, "local_name"):
                                variable_type = remove_namespace(sub_elem.local_name)
                            else:
                                variable_type = remove_namespace(sub_elem.type.name)
                            element = [variable_type, variable_name, is_vec]
                            elements.append(element)
                    else:
                        print(
                            "unprocessed element: " + struct_type_name + " has model type sequence but no type can be determined")
                        unprocessed_elements += 1
                        return
                else:
                    if struct_type_name == "FilterType":
                        # We dont care about the filtertype. Its done manually
                        return
                    print("unprocessed element: " + struct_type_name + " has model type but is not sequence")
                    unprocessed_elements += 1
                    return
            else:
                variable_name = remove_namespace(elem.name)
                variable_type = remove_namespace(elem.type.name)

                if variable_type is None or variable_type == "None":
                    if elem.type.base_type is None:
                        if variable_name == "version":
                            version_1_name = elem[0].local_name
                            version_1_type = remove_namespace(elem[0].type.name)

                            version_2_name = elem[1].local_name
                            version_2_type = remove_namespace(elem[1].type.name)
                            element_1 = [version_1_type, version_1_name, False]
                            element_2 = [version_2_type, version_2_name, False]
                            elements.append(element_1)
                            elements.append(element_2)
                            continue
                        elif variable_name == "dnsSd_mDns":  # this
                            variable_type = "ElementTagType"
                        elif variable_name == "dns":
                            print("Not processed AccessMethodsType.dns as its optional and a bit fiddly to implement")
                            unprocessed_elements += 1
                        else:
                            print("Still an unprocessed unknow element: " + struct_type_name + "." + variable_name)
                            unprocessed_elements += 1

                    else:
                        variable_type = remove_namespace(elem.type.base_type.name)
                if variable_type is None or variable_type == "None":
                    print("Variable type is still none")
                    unprocessed_elements += 1
                    return
                for enum_type in cpp_datatypes:
                    hypothetical_enum_type = re.sub(r'Type$', 'EnumType', variable_type)
                    if enum_type.type_name == "enum":
                        if enum_type.name == hypothetical_enum_type:
                            variable_type = hypothetical_enum_type

                if elem.max_occurs is None:
                    is_vec = True
                element = [variable_type, variable_name, is_vec]
                elements.append(element)
        for variable_type, variable_name, is_vec in elements:
            if variable_type == to_cpp_datatype(variable_type):
                new_type.depends_on.append(variable_type)
            variable_type = to_cpp_datatype(variable_type)
            variable_name_string = variable_name
            variable_name_cpp = make_variable_name(variable_name)

            # Handle edgecases
            if variable_type == "SpecificationVersionDataType":  # This is some weird edgecase
                variable_type = "SpecificationVersionType"

            # Done
            if is_vec:
                variable_type = "std::vector<" + variable_type + ">"
            new_type.code += f"\tSpineOptional<{variable_type}> {variable_name_cpp}{{}};\n"
            if variable_type == "None" or variable_type is None:
                print("Variable type is None while making complex type")
                unprocessed_elements += 1
                return
            new_type.to_json_code += f"""\tif (src.{variable_name_cpp}.has_value()) {{\n\t\tdst["{variable_name_string}"] = *src.{variable_name_cpp};\n\t}}\n"""
            new_type.from_json_code += f"""\tif (!src["{variable_name_string}"].isNull()) {{\n\t\tdst.{variable_name_cpp} = src["{variable_name_string}"].as<decltype(dst.{variable_name_cpp})::value_type>();\n\t}} else {{\n\t\tdst.{variable_name_cpp}.reset();\n\t}}\n"""
        #if its an empty element, we still need to generate the to/from json code but it doesnt need to do anything
        if len(elements) < 1:
            new_type.to_json_code = f"""bool convertToJson(const {struct_type_name} &src, JsonVariant& dst) {{\n"""
            new_type.from_json_code = f"""void convertFromJson(const JsonVariantConst& src, {struct_type_name} &dst) {{\n"""
        else:
            from_json_reformat = f"""void convertFromJson(const JsonVariantConst& src, {struct_type_name} &dst) {{\n\t\n\t\t{new_type.from_json_code}\n\t\n"""
            new_type.from_json_code = from_json_reformat

        new_type.code += f"\n\t{struct_type_name}(const {struct_type_name}& other) = default;\n"
        if not GENERATE_DEFAULT_CONSTRUCTOR:
            new_type.code += f"\n\t{struct_type_name}() = default;\n}};\n"
        else:
            new_type.code += f"\n\t{struct_type_name}()\n\t\t:"
            for variable_type, variable_name, is_vec in elements:
                variable_type = to_cpp_datatype(variable_type)
                variable_name_cpp = make_variable_name(variable_name)
                if is_vec:
                    variable_type = "std::vector<" + variable_type + ">"
                new_type.code += f"\n\t\t{variable_name_cpp}({variable_type}{{}}),"
            new_type.code = new_type.code[:-1]  # remove last comma
            new_type.code += "\n\t{}\n};\n"


        new_type.code += f"""/**\n * Convert a {struct_type_name} to its JSON representation\n * @param src The {struct_type_name} to convert\n * @param dst The JSON variant to fill with the converted data.\n * @return true if the conversion was successful, false otherwise.\n */\nbool convertToJson(const {struct_type_name} &src, JsonVariant& dst);\n"""
        new_type.code += f"""/**\n * Convert a JSON representation to a {struct_type_name}\n * @param src The JSON variant to convert\n * @param dst The {struct_type_name} to fill with the converted data.\n */\nvoid convertFromJson(const JsonVariantConst& src, {struct_type_name} &dst);\n\n"""

        new_type.to_json_code += "\n\treturn true;\n}\n"

        

        new_type.from_json_code += "\n}\n"
        cpp_datatypes.append(new_type)
        # print("type is sequence")
    # print("Generating code for complex type", remove_namespace(complex_type.name))
    # print("Generating code for complex type", remove_namespace(complex_type.name))


def process_schema(xml_schema):
    global unprocessed_elements
    # print("Generating code...")
    for simple_type in xml_schema.simple_types:

        if simple_type.derivation == "restriction":
            # restriction implies it is either a simple like "using Number = int" or an enum
            # Enum
            if simple_type.enumeration is not None:
                enum_type_name = remove_namespace(simple_type.name)
                new_type = Spine_type("enum", enum_type_name, "")
                # create enum and function headers
                new_type.code = f"/**\n* Datatype {enum_type_name} as defined in {simple_type.schema.name}\n*/\nenum class {enum_type_name} {{\n"
                # Prepare enumeration list and ensure undefined entry
                enum_variable_name = ""
                enum_list = simple_type.enumeration
                enum_undefined_name = "EnumUndefined"
                enum_list.append(enum_undefined_name)
                enum_list = list(dict.fromkeys(enum_list))

                # Build enum members and implementors
                # We'll generate:
                # - String convertToString(const Enum &src);
                # - bool convertToJson(const Enum &src, JsonVariant& dst);  // uses convertToString
                # - void convertFromString(const String &src, Enum &dst);
                # - void convertFromJson(const JsonVariantConst& src, Enum &dst); // uses convertFromString

                # Build the enum members
                for enumeration in enum_list:
                    enum_string_name = str(enumeration)
                    enum_variable_name = make_variable_name(enum_string_name)
                    if enum_string_name == enum_undefined_name:
                        new_type.code += "\t" + enum_variable_name + ", // This is not part of the spec but its needed for error handling\n"
                    else:
                        new_type.code += "\t" + enum_variable_name + ",\n"

                new_type.code += "};\n"

                # Prototypes (header)
                new_type.code += f"""/**\n * Convert the enum {enum_type_name} to its String representation\n */\nString convertToString(const {enum_type_name} &src);\n\n/**\n * Convert the enum {enum_type_name} to JSON (uses convertToString)\n */\nbool convertToJson(const {enum_type_name} &src, JsonVariant& dst);\n\n/**\n * Convert a string to a {enum_type_name}\n */\nvoid convertFromString(const String &src, {enum_type_name} &dst);\n\n/**\n * Convert a JSON variant containing a string to a {enum_type_name} (uses convertFromString)\n */\nvoid convertFromJson(const JsonVariantConst& src, {enum_type_name} &dst);\n\n"""

                # Implementation: convertToString + convertToJson
                to_string_impl = f"String convertToString(const {enum_type_name} &src) {{\n\tswitch(src) {{\n"
                for enumeration in enum_list:
                    enum_string_name = str(enumeration)
                    enum_variable_name = make_variable_name(enum_string_name)
                    if enum_string_name == enum_undefined_name:
                        # default handled after loop
                        continue
                    to_string_impl += f"\tcase {enum_type_name}::{enum_variable_name}:\n\t\treturn \"{enum_string_name}\";\n"
                # default -> EnumUndefined
                undefined_var = make_variable_name(enum_undefined_name)
                to_string_impl += f"\tdefault:\n\t\treturn \"{enum_undefined_name}\";\n\t}}\n}}\n\n"
                to_json_impl = f"bool convertToJson(const {enum_type_name} &src, JsonVariant& dst) {{\n\treturn dst.set(convertToString(src));\n}}\n\n"
                new_type.to_json_code = to_string_impl + to_json_impl

                # Implementation: convertFromString + convertFromJson
                from_string_impl = f"void convertFromString(const String &src, {enum_type_name} &dst) {{\n"
                for enumeration in enum_list:
                    enum_string_name = str(enumeration)
                    enum_variable_name = make_variable_name(enum_string_name)
                    if enum_string_name == enum_undefined_name:
                        continue
                    from_string_impl += f"\tif (src == \"{enum_string_name}\") {{\n\t\tdst = {enum_type_name}::{enum_variable_name};\n\t\treturn;\n\t}}\n"
                # fallback -> EnumUndefined
                from_string_impl += f"\tdst = {enum_type_name}::{undefined_var};\n}}\n\n"
                # convertFromJson uses as<const char*> to get string and then calls convertFromString
                from_json_impl = f"void convertFromJson(const JsonVariantConst& src, {enum_type_name} &dst) {{\n\tString s = src.as<const char*>();\n\tconvertFromString(s, dst);\n}}\n\n"
                new_type.from_json_code = from_string_impl + from_json_impl

                cpp_datatypes.append(new_type)

            # Using
            elif hasattr(simple_type, 'base_type'):
                new_type = Spine_type("using", remove_namespace(simple_type.name), "")

                new_type.code = "using " + remove_namespace(simple_type.name) + " = " + to_cpp_datatype(
                    simple_type.base_type.python_type) + ";\n"
                found_restriction = False
                if simple_type.base_type.max_value is not None:
                    new_type.max_value = simple_type.base_type.max_value
                    pass
                if simple_type.base_type.min_value is not None:
                    found_restriction = True
                    new_type.min_value = simple_type.base_type.min_value
                    found_restriction = True
                if to_cpp_datatype(simple_type.base_type.python_type) == "std::string":
                    found_restriction = True
                if hasattr(simple_type.base_type.python_type, 'name'):
                    if simple_type.base_type.python_type.name == "duration":
                        found_restriction = True
                if not found_restriction:
                    print("Unknown restriction to basetype", simple_type.name)
                cpp_datatypes.append(new_type)
                pass
            else:
                unprocessed_elements += 1
                print(
                    "simple type: " + simple_type.name + " has restriction but no enumeration. Not sure what to do with this")
        else:
            # else its a union aka a using type
            if hasattr(simple_type, 'member_types'):
                new_type = Spine_type("using", remove_namespace(simple_type.name), "")
                new_type.code = "using " + remove_namespace(simple_type.name) + " = " + to_cpp_datatype(
                    simple_type.python_type) + ";\n"
                cpp_datatypes.append(new_type)

            else:
                print("Unidentified Type", simple_type.name)
                unprocessed_elements += 1
    for complex_type in xml_schema.complex_types:
        process_complex_type(complex_type)

    ignored_types = ["filtertype", "payloadtype", "datagramtype", "hexbinary"]
    ignored_names = ["device", "entity", "feature", "hexbinary"]
    for element_name in xml_schema.elements._target_dict:
        if "{http://www.w3.org/2001/XMLSchema}" not in element_name:
            element_name_short = remove_namespace(element_name)
            element_type = remove_namespace(xml_schema.elements._target_dict[element_name].type.name)
            if element_name_short.lower() not in ignored_names and element_type.lower() not in ignored_types:
                mapping = (element_name_short, element_type)
                type_function_mapping.append(mapping)
        # print("Generating code for element", remove_namespace(element))


# Yes this i am aware this is really ugly python code
def generate_data_handler_class() -> (str, str):
    function_enum_entries = ''.join(f"\n\t\t\t{function[0]}," for function in type_function_mapping)
    type_enum_entries = ''.join(f"\n\t\t\t{function[1]}," for function in type_function_mapping)
    function_to_type_mapping = ''.join(
        f"\n\t\tcase SpineDataTypeHandler::Function::{function[0]}: return SpineDataTypeHandler::Type::{function[1]};"
        for function in type_function_mapping)
    string_to_function_mapping = ''.join(
        f"\n\tif (function_name == \"{function[0]}\") return SpineDataTypeHandler::Function::{function[0]};" for
        function in type_function_mapping)
    function_to_string_mapping = ''.join(
        f"\n\tif (function == SpineDataTypeHandler::Function::{function[0]}) return \"{function[0]}\";" for function in
        type_function_mapping)
    data_types = ''.join(
        f"\n\t\tSpineOptional<{cpp_datatype.name}> {cpp_datatype.name.lower()}{{}};" for cpp_datatype in cpp_datatypes)

    last_cmd_to_json_mapping = ''.join(f"""
    if (last_cmd == SpineDataTypeHandler::Function::{function[0]}) {{
        dst["{function[0]}"] = *{function[1].lower()};
    }}
    """ for function in type_function_mapping)
    cmd_types = ''.join(f"""
    if (obj["{function[0]}"]) {{
        last_cmd = function_from_string("{function[0]}");
        {function[1].lower()} =  obj["{function[0]}"].as<decltype({function[1].lower()})::value_type>();  
        return last_cmd;
    }}""" for function in type_function_mapping)

    reset_calls = ''.join(
        f"\n\t\t{cpp_datatype.name.lower()}.reset();" for cpp_datatype in cpp_datatypes)


    output_h = f"""
class SpineDataTypeHandler {{
    public:

        {data_types}
        enum class Function {{{function_enum_entries}
        None
        }};  
        enum class Type {{{type_enum_entries}
        None
        }};
        
        
        Function last_cmd;
        
        Type type_from_function(Function function);
        Function function_from_string(const String function_name);
        Function handle_cmd(JsonObjectConst obj);
        String function_to_string(Function function);
        void last_cmd_to_json(JsonVariant &dst);
        void reset();
}};
    """
    output_cpp_code = f"""
SpineDataTypeHandler::Type SpineDataTypeHandler::type_from_function(SpineDataTypeHandler::Function function) {{
    switch(function) {{{function_to_type_mapping}
    default:    
        return SpineDataTypeHandler::Type::None;
    }}
    return SpineDataTypeHandler::Type::None;
}}

SpineDataTypeHandler::Function SpineDataTypeHandler::function_from_string(const String function_name) {{
{string_to_function_mapping}
    return SpineDataTypeHandler::Function::None;
}}

SpineDataTypeHandler::Function SpineDataTypeHandler::handle_cmd(JsonObjectConst obj) {{
    {cmd_types}
    return SpineDataTypeHandler::Function::None;
}}
String SpineDataTypeHandler::function_to_string(Function function) {{
    {function_to_string_mapping}
    return "Unknown function";
}}

void SpineDataTypeHandler::last_cmd_to_json(JsonVariant &dst) {{
    {last_cmd_to_json_mapping}
}}

void SpineDataTypeHandler::reset() {{
    last_cmd = Function::None;
    {reset_calls}
}}
    """

    return output_h, output_cpp_code


def process_xsd_directory(input_dir, output_header_path, output_cpp_path, handling_type="spine", code_header="",
                          code_implementation=""):
    global cpp_datatypes, type_function_mapping
    cpp_datatypes = []
    print("Loading schema...")
    for xsd in os.listdir(input_dir):
        if xsd.endswith(".xsd"):
            print("Processing: " + xsd)
            schema = xmlschema.XMLSchema(os.path.join(input_dir, xsd))
            if schema.version != "1.3.0":
                print("WARNING: Schema version is not 1.3.0. This might cause issues.")
            process_schema(schema)

    print("Deduplicating and sorting code...")
    print("Elements Before: ", len(cpp_datatypes))
    print("Functions before: ", len(type_function_mapping))
    cpp_datatypes = remove_duplicate_objects(cpp_datatypes)
    type_function_mapping = remove_duplicate_function_mappings(type_function_mapping)
    print("Elements After: ", len(cpp_datatypes))
    print("Functions after: ", len(type_function_mapping))
    print("Resolving Type Dependencies...")
    cpp_datatypes = sort_and_resolve_dependencies(cpp_datatypes)

    data_handler_header = ""
    data_handler_cpp = ""
    if handling_type == "spine":
        data_handler_header, data_handler_cpp = generate_data_handler_class()

    print("Writing code to files...")
    with open(output_header_path, "w") as h, open(output_cpp_path, "w") as cpp:
        h.write(code_header)
        cpp.write(code_implementation)
        h.write("\n\n\n\n")
        for datatype in cpp_datatypes:
            h.write(datatype.code)
            cpp.write(datatype.to_json_code)
            cpp.write(datatype.from_json_code)
        h.write("\n\n\n\n")
        h.write(data_handler_header)
        cpp.write(data_handler_cpp)
        # Both have headertypes and we need to replace them in one
    if handling_type == "ship":
        print("Running in SHIP Mode. Adapting code a bit")
        with open(output_header_path, "r") as f:
            content = f.read()
        content = content.replace("HeaderType", "SpineHeaderType")
        with open(output_header_path, "w") as f:
            f.write(content)

        with open(output_cpp_path, "r") as f:
            content = f.read()
        content = content.replace("HeaderType", "SpineHeaderType")
        with open(output_cpp_path, "w") as f:
            f.write(content)
    with open(output_header_path, "r") as h, open(output_cpp_path, "r") as cpp:
        print(f"Wrote {len(h.readlines())} LOC to header ")
        print(f"Wrote {len(cpp.readlines())} LOC to cpp")

    print(f"Unprocessed elements: {unprocessed_elements}")
    print(f"Processed all schemas in {input_dir} and wrote to {output_header_path} and {output_cpp_path}")


# spine_path = "SPINE"
# output_header = "spine_types.h"
# output_cpp = "spine_types.cpp"
# process_xsd_directory(spine_path, output_header, output_cpp, handling_type="spine", code_header=spine_cpp_header_header, code_implementation=spine_cpp_implementation_header)

# spine_path = "SHIP"
# output_header = "ship_types_new.h"
# output_cpp = "ship_types_new.cpp"
# process_xsd_directory(spine_path, output_header, output_cpp, handling_type="ship", code_header=ship_cpp_header_header, code_implementation=ship_cpp_implementation_header)

# print("Done!")


def main():
    parser = argparse.ArgumentParser(description="Generate C++ code for SPINE and SHIP types from XSD files.")
    #parser.add_argument('--no-ship', action='store_true',
    #                    help='Do not process SHIP XSD files. Defaults to processing SHIP files.')
    parser.add_argument('--no-spine', action='store_true',
                        help='Do not process SPINE XSD files. Defaults to processing SPINE files.')
    parser.add_argument('--spine-input', default='SPINE',
                        help='Input directory for SPINE XSD files. Defaults to "SPINE".')
    parser.add_argument('--spine-output', default='spine_types',
                        help='Output filename for SPINE C++ code (without file extension). Defaults to "spine_types". which generates "spine_types.h" and "spine_types.cpp".')
    #parser.add_argument('--ship-input', default='SHIP', help='Input directory for SHIP XSD files. Defaults to "SHIP".')
    #parser.add_argument('--ship-output', default='ship_types_new',
    #                    help='Output filename for SHIP C++ code (without file extension). Defaults to "ship_types_new". which generates "ship_types_new.h" and "ship_types_new.cpp".')

    args = parser.parse_args()

    if not args.no_spine:
        print("Processing SPINE XSD files...")
        spine_path = args.spine_input
        output_header = args.spine_output + ".h"
        output_cpp = args.spine_output + ".cpp"
        spine_cpp_implementation_header.replace("spine_types.h", output_header)
        process_xsd_directory(spine_path, output_header, output_cpp, handling_type="spine",
                              code_header=spine_cpp_header_header, code_implementation=spine_cpp_implementation_header)
        print("Done processing SPINE XSD files.")

    #if not args.no_ship:
    #    print("Processing SHIP XSD files...")
    #    ship_path = args.ship_input
    #    output_header = args.ship_output + ".h"
    #    output_cpp = args.ship_output + ".cpp"
    #    process_xsd_directory(ship_path, output_header, output_cpp, handling_type="ship",
    #                          code_header=ship_cpp_header_header, code_implementation=ship_cpp_implementation_header)
    #    if args.no_spine:
    #        print("WARNING: SHIP code is generated without SPINE code. SHIP requires SPINE to function properly.")
    #    print("Done processing SHIP XSD files.")
    print("Done!")


if __name__ == "__main__":
    main()
